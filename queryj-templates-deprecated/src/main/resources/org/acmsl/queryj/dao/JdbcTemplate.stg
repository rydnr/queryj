//;-*- mode: antlr -*-
//
//                      QueryJ
//
//  Copyright (C) 2002-today  ACM-SL
//                           chous@acm-sl.org
//
//  This library is free software; you can redistribute it and/or
//  modify it under the terms of the GNU General Public
//  License as published by the Free Software Foundation; either
//  version 2 of the License, or any later version.
//
//  This library is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//  General Public License for more details.
//
//  You should have received a copy of the GNU General Public
//  License along with this library; if not, write to the Free Software
//  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
//
//  Thanks to ACM S.L. for distributing this library under the GPL license.
//  Contact info: jose.sanleandro@acm-sl.com
//  Postal Address: c/Playa de Lagoa, 1
//                  Urb. Valdecabanas
//                  Boadilla del monte
//                  28660 Madrid
//                  Spain
//
//***************************************************************************
//
// Filename: JdbcTemplate.stg
//
// Author: Jose San Leandro Armendariz
//
// Description: Customizes JdbcTemplate to deal with proper connection
//              handling.
//
group JdbcTemplate;

source() ::= <<
<!
  Generates a JdbcTemplate implementation.
!>
<if(header)>
<header>
<else>
<java_header(
  year=current_year,
  description=
  [
    first_line_description(
      engineName=engine_name,
      engineVersion=engine_version),
    second_line_description(
      engineName=engine_name,
      engineVersion=engine_version)
  ],
  timestamp=timestamp)>
<endif>
<if(generation_timestamps_enabled)>
// Generated by org/acmsl/queryj/dao/JdbcTemplate.stg at <timestamp>
<endif>

<package_declaration(package=package)>

<project_imports(
  basePackageName=project_package,
  baseDAOSubpackageName=typeInitMap.baseDAOSubpackageName,
  rdbSubpackageName=typeInitMap.rdbSubpackageName,
  trName=repository.capitalized)>

/*
 * Importing Spring classes.
 */
import org.springframework.dao.DataAccessException;
import org.springframework.jdbc.core.ConnectionCallback;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.jdbc.core.PreparedStatementCallback;
import org.springframework.jdbc.core.PreparedStatementCreator;
import org.springframework.jdbc.core.PreparedStatementCreatorFactory;
import org.springframework.jdbc.core.PreparedStatementSetter;
import org.springframework.jdbc.core.ResultSetExtractor;
import org.springframework.jdbc.core.SqlParameter;
import org.springframework.jdbc.core.StatementCallback;
import org.springframework.jdbc.datasource.ConnectionHolder;
import org.springframework.jdbc.datasource.DataSourceTransactionManager;
import org.springframework.jdbc.datasource.DataSourceUtils;
<!//import org.springframework.jdbc.datasource.TransactionAwareDataSourceProxy;!>
import org.springframework.jdbc.object.SqlQuery;
import org.springframework.jdbc.SQLWarningException;
import org.springframework.jdbc.support.JdbcUtils;
import org.springframework.jdbc.support.nativejdbc.NativeJdbcExtractor;
import org.springframework.jdbc.support.SQLExceptionTranslator;
import org.springframework.transaction.support.TransactionCallback;
import org.springframework.transaction.support.TransactionSynchronizationAdapter;
import org.springframework.transaction.support.TransactionSynchronizationManager;
import org.springframework.transaction.support.TransactionTemplate;
import org.springframework.transaction.TransactionException;
import org.springframework.transaction.TransactionStatus;
import org.springframework.jdbc.core.ParameterDisposer;
import org.springframework.jdbc.core.SqlProvider;

/*
 * Importing some JDK classes.
 */
import java.math.BigDecimal;
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.SQLWarning;
import java.sql.Statement;
import java.sql.Types;
import java.util.Calendar;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

/*
 * Importing some JDK extension classes
 */
import javax.sql.DataSource;

/*
 * Importing Jakarta Commons Logging classes
 */
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;

<class()>
>>

first_line_description(engineName, engineVersion) ::= <<
<!
  Generates a description for the generated file.
  @param engineName the engine name.
  @param engineVersion the engine version.
!>
Creates the {@link PreparedStatement}
>>

second_line_description(engineName, engineVersion) ::= <<
<!
  Generates a description for the generated file.
  @param engineName the engine name.
  @param engineVersion the engine version.
!>
required to perform any \<i>JDBC\</i> operation.
>>

project_imports(
  basePackageName,
  baseDAOSubpackageName,
  rdbSubpackageName,
  trName) ::= <<
<!
 Generates the project imports.
 @param basePackageName the base package name.
 @param baseDAOSubpackageName the base DAO subpackage name.
 @param rdbSubpackageName the rdb subpackage name.
 @param trName the repository name.
!>
/*
 * Importing project classes.
 */
import <basePackageName>.<baseDAOSubpackageName>.<rdbSubpackageName>.<trName>DAOListener;
>>

class() ::= <<
<!
 Generates the class body.
 @param vo_name the value object name.
 @param engine_name the engine name.
 @param engine_version the engine version.
 @param timestamp the timestamp.
 @param custom_results the results for the custom queries.
 @param tr_name the repository name.
!>
/**
 * <[
      first_line_description(
        engineName=engine_name,
        engineVersion=engine_version),
      second_line_description(
        engineName=engine_name,
        engineVersion=engine_version)
    ]:{line |<line>}; separator="\n * ">
<class_common_javadoc(template="org/acmsl/queryj/dao/JdbcTemplate.stg")>
 */
<class_annotations()>
public class <repository.capitalized>JdbcTemplate
    extends  JdbcTemplate
{
    /**
     * The audit log category.
     */
    public static final String AUDITLOG_CATEGORY = "<repository.lowercased>-queryj-auditlog";
    
    /**
     * Whether to enable auditlog or not.
     */
    private static boolean enableAuditLog = false;

    /**
     * The DAOListener instance.
     */
    private <repository.capitalized>DAOListener <repository.uncapitalized>DAOListener;

    /**
     * Creates a new JdbcTemplate.
     */
    public <repository.capitalized>JdbcTemplate(
        <nullable()>final <repository.capitalized>DAOListener daoListener)
    {
        immutableSetDAOListener(daoListener);
    }


    /**
     * Construct a new {@link <repository.capitalized>JdbcTemplate},
     * given a DataSource to obtain connections from.
     * Note: This will trigger eager initialization of the exception translator.
     * @param dataSource JDBC {@link DataSource} to obtain connections from.
     * @param daoListener the {@link <repository.capitalized>DAOListener} instance.
     */
    public <repository.capitalized>JdbcTemplate(
        <notnull()>final DataSource dataSource,
        <nullable()>final <repository.capitalized>DAOListener daoListener)
    {
        super(dataSource);
        immutableSetDAOListener(daoListener);
    }

    /**
     * Specifies the DAO listener.
     * @param daoListener such listener.
     */
    protected final void immutableSetDAOListener(
        <notnull()>final <repository.capitalized>DAOListener daoListener)
    {
        <repository.uncapitalized>DAOListener = daoListener;
    }

    /**
     * Specifies the DAO listener.
     * @param daoListener such listener.
     */
    @SuppressWarnings("unused")
    protected void setDAOListener(
        <notnull()>final <repository.capitalized>DAOListener daoListener)
    {
        immutableSetDAOListener(daoListener);
    }

    /**
     * Retrieves the DAO listener.
     * @return such instance.
     */
    <nullable()>
    protected <repository.capitalized>DAOListener getDAOListener()
    {
        return <repository.uncapitalized>DAOListener;
    }

    /**
     * Retrieves the {@link DataSource data source}.
     * @return such instance.
     */
    <notnull()>
    public synchronized DataSource getSynchronizedDataSource()
    {
        return getDataSource();
    }

    /**
     * Executes a operation, taking into account a proper connection handling.
     * @param action the {@link ConnectionCallback} instance.
     * @return the result of the operation.
     */
    <nullable()>
    public Object execute(<notnull()>final ConnectionCallback action)
        throws DataAccessException
    {
        return
            execute(
                action,
                getSql(action),
                getDataSource(),
                getDAOListener(),
                getNativeJdbcExtractor(),
                getExceptionTranslator());
    }

    /**
     * Executes a operation, taking into account a proper connection handling.
     * @param action the {@link ConnectionCallback} instance.
     * @param sql the original SQL.
     * @param dataSource the {@link DataSource} instance.
     * @param daoListener the {@link <repository.capitalized>DAOListener} instance.
     * @param nativeJdbcExtractor the native JDBC extractor.
     * @param exceptionTranslator the exception translator.
     * @return the result of the operation.
     */
    @SuppressWarnings("unchecked")
    <nullable()>
    protected Object execute(
        <notnull()>final ConnectionCallback action,
        <notnull()>final String sql,
        <notnull()>final DataSource dataSource,
        <nullable()>final <repository.capitalized>DAOListener daoListener,
        <nullable()>final NativeJdbcExtractor nativeJdbcExtractor,
        <notnull()>final SQLExceptionTranslator exceptionTranslator)
      throws DataAccessException
    {
        Object result = null;

        Connection connection = null;

        boolean closeConnection = false;

        DataSource localDataSource = dataSource;

<!
//        if  (!(dataSource instanceof TransactionAwareDataSourceProxy))
//        {
//            localDataSource = new TransactionAwareDataSourceProxy(dataSource);
//        }
!>
        try
        {
            ConnectionHolder connectionHolder =
                (ConnectionHolder)
                    TransactionSynchronizationManager.getResource(
                        localDataSource);

            if  (connectionHolder != null)
            {
                connection = connectionHolder.getConnection();
            }
            else
            {
                connection = dataSource.getConnection();
                closeConnection = true;
            }

            daoListener.connectionRetrieved(sql);

            if  (   (closeConnection)
                 && (TransactionSynchronizationManager.isSynchronizationActive()))
            {
                connectionHolder = new ConnectionHolder(connection);

                TransactionSynchronizationManager.bindResource(
                    dataSource, connectionHolder);

                TransactionSynchronizationManager.registerSynchronization(
                    new ConnectionSynchronization(
                        connectionHolder, dataSource));
            }

            Connection connectionToUse = connection;

            if  (nativeJdbcExtractor != null)
            {
                connectionToUse =
                    nativeJdbcExtractor.getNativeConnection(connection);
            }

            result = action.doInConnection(connectionToUse);
        }
        catch  (<notnull()>final SQLException sqlException)
        {
            throw
                exceptionTranslator.translate(
                    "executing ConnectionCallback",
                    sql,
                    sqlException);
        }
        finally
        {
            if  (   (closeConnection)
                 && (connection != null))
            {
                try
                {
                    connection.close();
                }
                catch  (<notnull()>final SQLException sqlException)
                {
                    LogFactory.getLog(<repository.capitalized>JdbcTemplate.class).info(
                        "Could not close connection",
                        sqlException);
                }
            }

            daoListener.connectionReleased(sql);
        }

        return result;
    }

    /**
     * Executes a operation, taking into account a proper connection handling.
     * @param action the {@link StatementCallback} instance.
     * @return the result of the operation.
     */
    <nullable()>
    public Object execute(<notnull()>final StatementCallback action)
        throws DataAccessException
    {
        return
            execute(
                action,
                getSql(action),
                getDataSource(),
                getDAOListener(),
                getNativeJdbcExtractor(),
                getExceptionTranslator());
    }

    /**
     * Executes a operation, taking into account a proper connection handling.
     * @param action the {@link StatementCallback} instance.
     * @param sql the original SQL.
     * @param dataSource the {@link DataSource} instance.
     * @param daoListener the {@link <repository.capitalized>DAOListener} instance.
     * @param nativeJdbcExtractor the native JDBC extractor.
     * @param exceptionTranslator the exception translator.
     * @return the result of the operation.
     */
    @SuppressWarnings("unchecked")
    <nullable()>
    protected Object execute(
        <notnull()>final StatementCallback action,
        <notnull()>final String sql,
        <notnull()>final DataSource dataSource,
        <nullable()>final <repository.capitalized>DAOListener daoListener,
        <nullable()>final NativeJdbcExtractor nativeJdbcExtractor,
        <notnull()>final SQLExceptionTranslator exceptionTranslator)
      throws DataAccessException
    {
        Object result = null;

        Connection connection = null;

        boolean closeConnection = false;

        Statement statement = null;

        DataSource localDataSource = dataSource;

<!
//        if  (!(dataSource instanceof TransactionAwareDataSourceProxy))
//        {
//            t_DataSource = new TransactionAwareDataSourceProxy(dataSource);
//        }
!>
        try
        {
            ConnectionHolder connectionHolder =
                (ConnectionHolder)
                    TransactionSynchronizationManager.getResource(
                        localDataSource);

            if  (connectionHolder != null)
            {
                connection = connectionHolder.getConnection();
            }
            else
            {
                connection = dataSource.getConnection();
                closeConnection = true;
            }

            daoListener.connectionRetrieved(sql);

            if  (   (closeConnection)
                 && (TransactionSynchronizationManager.isSynchronizationActive()))
            {
                // use same Connection for further JDBC actions within the transaction
                // thread object will get removed by synchronization at transaction completion
                connectionHolder = new ConnectionHolder(connection);

                TransactionSynchronizationManager.bindResource(
                    dataSource, connectionHolder);

                TransactionSynchronizationManager.registerSynchronization(
                    new ConnectionSynchronization(
                        connectionHolder, localDataSource));
            }

            Connection connectionToUse = connection;

            if  (   (nativeJdbcExtractor != null)
                 && (nativeJdbcExtractor.isNativeConnectionNecessaryForNativeStatements()))
            {
                connectionToUse =
                    nativeJdbcExtractor.getNativeConnection(connection);
            }

            statement = connectionToUse.createStatement();

            DataSourceUtils.applyTransactionTimeout(
                statement, dataSource);
            
            Statement statementToUse = statement;

            if  (nativeJdbcExtractor != null)
            {
                statementToUse =
                    nativeJdbcExtractor.getNativeStatement(statement);
            }

            result = action.doInStatement(statementToUse);

            SQLWarning warning = statementToUse.getWarnings();

            throwExceptionOnWarningIfNotIgnoringWarnings(warning);
        }
        catch (<notnull()>final SQLException sqlException)
        {
            throw exceptionTranslator.translate(
                "executing StatementCallback", sql, sqlException);
        }
        finally
        {
            JdbcUtils.closeStatement(statement);

            if  (   (closeConnection)
                 && (connection != null))
            {
                try
                {
                    connection.close();
                }
                catch  (<notnull()>final SQLException sqlException)
                {
                    LogFactory.getLog(<repository.capitalized>JdbcTemplate.class).info(
                        "Could not close connection",
                        sqlException);
                }
            }

            daoListener.connectionReleased(sql);
        }

        return result;
    }

    /**
     * Executes a operation, taking into account a proper connection handling.
     * @param psc the {@link preparedStatementCreator} instance.
     * @param action the {@link PreparedStatementCallback} instance.
     * @return the result of the operation.
     */
    <nullable()>
    public Object execute(
        <notnull()>final PreparedStatementCreator preparedStatementCreator,
        <notnull()>final PreparedStatementCallback action)
      throws DataAccessException
    {
        return
            execute(
                preparedStatementCreator,
                action,
                getSql(action),
                getDataSource(),
                getDAOListener(),
                getNativeJdbcExtractor(),
                getExceptionTranslator());
    }

    /**
     * Executes a operation, taking into account a proper connection handling.
     * @param preparedStatementCreator the {@link PreparedStatementCreator}
     * instance.
     * @param action the {@link PreparedStatementCallback} instance.
     * @param sql the original SQL.
     * @param dataSource the {@link DataSource} instance.
     * @param daoListener the {@link <repository.capitalized>DAOListener} instance.
     * @param nativeJdbcExtractor the native JDBC extractor.
     * @param exceptionTranslator the exception translator.
     * @return the result of the operation.
     */
    @SuppressWarnings("unchecked")
    <nullable()>
    protected Object execute(
        <notnull()>final PreparedStatementCreator preparedStatementCreator,
        <notnull()>final PreparedStatementCallback action,
        <notnull()>final String sql,
        <notnull()>final DataSource dataSource,
        <notnull()>final <repository.capitalized>DAOListener daoListener,
        <nullable()>final NativeJdbcExtractor nativeJdbcExtractor,
        <notnull()>final SQLExceptionTranslator exceptionTranslator)
      throws DataAccessException
    {
        Object result = null;

        Connection connection = null;

        boolean closeConnection = false;

        PreparedStatement preparedStatement = null;

        DataSource localDataSource = dataSource;
<!
//        if  (!(dataSource instanceof TransactionAwareDataSourceProxy))
//        {
//            t_DataSource = new TransactionAwareDataSourceProxy(dataSource);
//        }
!>
        try
        {
            ConnectionHolder connectionHolder =
                (ConnectionHolder)
                    TransactionSynchronizationManager.getResource(
                        localDataSource);

            if  (connectionHolder != null)
            {
                connection = connectionHolder.getConnection();
            }
            else
            {
                connection = localDataSource.getConnection();
                closeConnection = true;
            }

            daoListener.connectionRetrieved(sql);

            if  (   (closeConnection)
                 && (TransactionSynchronizationManager.isSynchronizationActive()))
            {
                // use same Connection for further JDBC actions within the transaction
                // thread object will get removed by synchronization at transaction completion
                connectionHolder = new ConnectionHolder(connection);

                TransactionSynchronizationManager.bindResource(
                    localDataSource, connectionHolder);

                TransactionSynchronizationManager.registerSynchronization(
                    new ConnectionSynchronization(
                        connectionHolder, localDataSource));
            }

            Connection connectionToUse = connection;

            if  (   (nativeJdbcExtractor != null)
                 && (nativeJdbcExtractor
                         .isNativeConnectionNecessaryForNativePreparedStatements()))
            {
                connectionToUse =
                    nativeJdbcExtractor.getNativeConnection(connection);
            }

            preparedStatement =
                preparedStatementCreator.createPreparedStatement(
                    connectionToUse);

            daoListener.statementPrepared(sql);

            DataSourceUtils.applyTransactionTimeout(
                preparedStatement, dataSource);
            
            PreparedStatement preparedStatementToUse =
                preparedStatement;

            if  (nativeJdbcExtractor != null)
            {
                preparedStatementToUse =
                    nativeJdbcExtractor.getNativePreparedStatement(
                        preparedStatement);
            }

            result = action.doInPreparedStatement(preparedStatementToUse);

            SQLWarning warning = preparedStatementToUse.getWarnings();
            
            throwExceptionOnWarningIfNotIgnoringWarnings(warning);
        }
        catch  (<notnull()>final SQLException sqlException)
        {
            throw
                exceptionTranslator.translate(
                      "executing PreparedStatementCallback ["
                    + preparedStatementCreator + "]",
                    sql,
                    sqlException);
        }
        finally
        {
            if  (preparedStatementCreator instanceof ParameterDisposer)
            {
                ((ParameterDisposer) preparedStatementCreator)
                    .cleanupParameters();
            }

            JdbcUtils.closeStatement(preparedStatement);

            daoListener.statementReleased(sql);

            if  (   (closeConnection)
                 && (connection != null))
            {
                try
                {
                    connection.close();
                }
                catch  (<notnull()>final SQLException sqlException)
                {
                    LogFactory.getLog(<repository.capitalized>JdbcTemplate.class).info(
                        "Could not close connection",
                        sqlException);
                }
            }

            daoListener.connectionReleased(sql);
        }

        return result;
    }

    /**
     * Determine SQL from potential provider object.
     * @param sqlProvider object that's potentially a SqlProvider
     * @return the SQL string, or null
     * @see SqlProvider
     */
    <nullable()>
    protected String getSql(<notnull()>final Object sqlProvider)
    {
        String result = null;

        if  (sqlProvider instanceof SqlProvider)
        {
            result = ((SqlProvider) sqlProvider).getSql();
        }

        return result;
    }

    /**
     * Throw an SQLWarningException if we're not ignoring warnings.
     * @param warning warning from current statement. May be null,
     * in which case this method does nothing.
     */
    protected void throwExceptionOnWarningIfNotIgnoringWarnings(
        <notnull()>final SQLWarning warning)
        throws SQLWarningException
    {
        throwExceptionOnWarningIfNotIgnoringWarnings(warning, isIgnoreWarnings());
    }

    /**
     * Throw an SQLWarningException if we're not ignoring warnings.
     * @param warning warning from current statement. May be null,
     * in which case this method does nothing.
     * @param ignoreWarnings whether to ignore warnings.
     */
    protected void throwExceptionOnWarningIfNotIgnoringWarnings(
        <notnull()>final SQLWarning warning, final boolean ignoreWarnings)
      throws SQLWarningException
    {
        if (!ignoreWarnings)
        {
            throw new SQLWarningException("Warning not ignored", warning);
        }
    }

    /**
     * Callback for resource cleanup at the end of a non-native-JDBC transaction
     * (e.g. when participating in a JTA transaction).
     */
    private static class ConnectionSynchronization 
        extends TransactionSynchronizationAdapter
    {
        private final ConnectionHolder connectionHolder;

        private final DataSource dataSource;

        private ConnectionSynchronization(
            <notnull()>final ConnectionHolder connectionHolder,
            <notnull()>final DataSource dataSource)
        {
            this.connectionHolder = connectionHolder;
            this.dataSource = dataSource;
        }

        /**
         * {@inheritDoc}
         */
        @Override
        public void suspend()
        {
            TransactionSynchronizationManager.unbindResource(
                this.dataSource);
        }

        /**
         * {@inheritDoc}
         */
        @Override
        public void resume()
        {
            TransactionSynchronizationManager.bindResource(
                this.dataSource, this.connectionHolder);
        }

        /**
         * {@inheritDoc}
         */
        @Override
        public void beforeCompletion()
        {
            TransactionSynchronizationManager.unbindResource(this.dataSource);

            DataSourceUtils.releaseConnection(
                this.connectionHolder.getConnection(), this.dataSource);
        }
    }

    /**
     * Audits given sql.
     * @param sql the original sql.
     * @return the auditted sql.
     */
    @SuppressWarnings("unchecked")
    <notnull()>
    protected static String auditSql(<notnull()>final String sql)
    {
        <notnull()>final StringBuilder result = new StringBuilder();
    
        Map map = <repository.capitalized>ThreadLocalBag.getThreadBag();

        boolean enableAuditLog = getEnableAuditLog();
        
        if  (   (enableAuditLog)
             && (map != null))
        {
            String user = (String) map.get(<repository.capitalized>ThreadLocalBag.PRINCIPAL);
            String ip = (String) map.get(<repository.capitalized>ThreadLocalBag.REMOTE_IP);
    
            if  (   (user != null)
                 || (ip != null))
            {
                result.append("/* ");
            }
    
            if  (user != null)
            {
                result.append(user);
                result.append("|");
            }
    
            if  (ip != null)
            {
                result.append(ip);
            }
    
            if  (   (user != null)
                 || (ip != null))
            {
                result.append(" */");
            }
        }
    
        result.append(sql);

        if  (enableAuditLog)
        {
            auditLog();
        }

        return result.toString();
    }
    
    /**
     * Performs an audit log.
     */
    @SuppressWarnings("unchecked")
    protected static void auditLog()
    {
        Log log = LogFactory.getLog(AUDITLOG_CATEGORY);
        Map map = <repository.capitalized>ThreadLocalBag.getThreadBag();
    
        if  (   (map != null)
             && (getEnableAuditLog())
             && (log.isInfoEnabled())
             && (map.size() > 0))
        {
            log.info(map.toString());
        }
    }

    /**
     * Specifies whether to enable auditlog or not.
     * @param flag such flag.
     */
    protected static final void immutableSetEnableAuditLog(final boolean flag)
    {
        enableAuditLog = flag;
    }

    /**
     * Specifies whether to enable auditlog or not.
     * @param flag such flag.
     */
    public static void setEnableAuditLog(final boolean flag)
    {
        immutableSetEnableAuditLog(flag);
    }

    /**
     * Retrieves whether the auditlog is enabled.
     * @return such information.
     */
    protected static final boolean immutableGetEnableAuditLog()
    {
        return enableAuditLog;
    }

    /**
     * Retrieves whether the auditlog is enabled.
     * @return such information.
     */
    public static boolean getEnableAuditLog()
    {
        return immutableGetEnableAuditLog();
    }
}
>>
