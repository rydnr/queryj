//;-*- mode: antlr -*-
//
//                      QueryJ
//
//  Copyright (C) 2002-2007  ACM-SL
//                           chous@acm-sl.org
//
//  This library is free software; you can redistribute it and/or
//  modify it under the terms of the GNU General Public
//  License as published by the Free Software Foundation; either
//  version 2 of the License, or any later version.
//
//  This library is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//  General Public License for more details.
//
//  You should have received a copy of the GNU General Public
//  License along with this library; if not, write to the Free Software
//  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
//
//  Thanks to ACM S.L. for distributing this library under the GPL license.
//  Contact info: jose.sanleandro@acm-sl.com
//  Postal Address: c/Playa de Lagoa, 1
//                  Urb. Valdecabanas
//                  Boadilla del monte
//                  28660 Madrid
//                  Spain
//
//***************************************************************************
//
// Filename: StatisticsProvider.stg
//
// Author: Jose San Leandro Armendariz
//
// Description: Generates StatisticsProvider sources.
//
group StatisticsProvider;

source(input) ::= <<
<!
  Generates a StatisticsProvider source.
!>
<if(header)>
<header>
<else>
<java_header(
  year=current_year,
  description=
  [
    first_line_description()
  ],
  timestamp=timestamp)>
<endif>
<if(generation_timestamps_enabled)>
// Generated by org/acmsl/queryj/dao/StatisticsProvider.stg at <timestamp>
<endif>

<package_declaration(package=package)>

/*
 * Importing some Spring classes.
 */
import org.springframework.jdbc.core.ConnectionCallback;
import org.springframework.jdbc.core.StatementCallback;
import org.springframework.jdbc.core.PreparedStatementCallback;
import org.springframework.jdbc.core.PreparedStatementCreator;

/*
 * Importing some JDK classes.
 */
import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Date;

<class(input=input)>
>>

first_line_description() ::= <<
<!
  Generates a description for the generated file.
!>
Provides statistics about QueryJ-generated persistence layer.
>>

class(input) ::= <<
<!
 Generates the class body.
 @param timestamp the timestamp.
 @param tr_name the table repository name.
!>
/**
 * <[
      first_line_description()
    ]:{line |<line>}; separator="\n * ">
<class_common_javadoc(template="org/acmsl/queryj/dao/StatisticsProvider.stg")>
 */
<class_annotations()>
public class <repository.capitalized>StatisticsProvider
{
    /**
     * The default map size.
     */
    protected static final int DEFAULT_MAP_SIZE = 20;

    /**
     * The map storing per-{@link java.sql.Connection} statistics.
     */
    private static final Map\<String, Integer\> CONNECTIONS_OPENED_PER_SQL =
        new HashMap\<String, Integer\>(DEFAULT_MAP_SIZE);

    /**
     * The map storing the time a transaction lasts, for a given SQL.
     */
    private static final Map\<String, List\<Sample\>\> TRANSACTION_DURATION =
        new HashMap\<String, List\<Sample\>\>(DEFAULT_MAP_SIZE);

    /**
     * The counter of alive connections.
     */
    private static int connectionsAlive = 0;

    /**
     * The map storing per-{@link java.sql.PreparedStatement} statistics.
     */
    private static final Map\<String, Integer\> STATEMENTS_OPENED_PER_SQL =
        new HashMap\<String, Integer\>(DEFAULT_MAP_SIZE);

    /**
     * The map storing the time the statement is opened, per SQL.
     */
    private static final Map\<String, List\<Sample\>\> SQL_DURATION =
        new HashMap\<String, List\<Sample\>\>(DEFAULT_MAP_SIZE);

    /**
     * The counter of alive statements.
     */
    private static int statementsAlive = 0;

    /**
     * The map storing per-{@link java.sql.ResultSet} statistics.
     */
    private static final Map\<String, Integer\> ROWS_RETRIEVED_PER_SQL =
        new HashMap\<String, Integer\>(DEFAULT_MAP_SIZE);

    /**
     * The map storing the time it takes to retrieve all rows, per SQL.
     */
    private static final Map\<String, List\<Sample\>\> ROW_RETRIEVAL_DURATION =
        new HashMap\<String, List\<Sample\>\>(DEFAULT_MAP_SIZE);

    /**
     * The counter of alive result sets.
     */
    private static int resultSetsAlive = 0;

    /**
     * Singleton implemented to avoid double-locking check.
     */
    protected static final class <repository.capitalized>StatisticsProviderSingletonContainer
    {
        /**
         * The actual singleton.
         */
        public static final <repository.capitalized>StatisticsProvider SINGLETON =
            new <repository.capitalized>StatisticsProvider();
    }

    /**
     * A helper class to store sample timestamps.
     */
    protected static final class Sample
    {
        private final Date start = new Date();
        private Date end;

        /**
         * Annotates the closing timestamp.
         */
        public void close()
        {
            if (this.end == null)
            {
                this.end = new Date();
            }
            // else log warning since it's already closed
        }

        /**
         * Retrieves the duration.
         * @return such information.
         */
        public long getDuration()
        {
            Date endTime = this.end;

            if (endTime == null)
            {
                endTime = new Date();
            }

            return getDuration(this.start, endTime);
        }

        /**
         * Retrieves the duration.
         * @param start the starting point.
         * @param end the ending point.
         * @return such information.
         */
        protected long getDuration(
            <notnull()>final Date start, <notnull()>final Date end)
        {
            return end.getTime() - start.getTime();
        }
    }
            
    /**
     * Retrieves the singleton instance.
     * @return such instance.
     */
    public static <repository.capitalized>StatisticsProvider getInstance()
    {
        return <repository.capitalized>StatisticsProviderSingletonContainer.SINGLETON;
    }

    /**
     * Annotates a connection is retrieved.
     * @param sql the SQL sentence.
     */
    public synchronized void annotateConnectionRetrieved(
        <notnull()>final String sql)
    {
        int connectionCount = CONNECTIONS_OPENED_PER_SQL.get(sql);

        CONNECTIONS_OPENED_PER_SQL.put(sql, connectionCount++);

        connectionsAlive++;

        List\<Sample\> timestamps = TRANSACTION_DURATION.get(sql);

        if (timestamps == null)
        {
            timestamps = new ArrayList\<Sample\>(1);
            timestamps.add(new Sample());
            TRANSACTION_DURATION.put(sql, timestamps);
        }
        // else log warning since it is already opened!
    }

    /**
     * Annotates a connection is released.
     * @param sql the SQL sentence.
     */
    public void annotateConnectionReleased(<notnull()>final String sql)
    {
        int connectionCount = CONNECTIONS_OPENED_PER_SQL.get(sql);

        CONNECTIONS_OPENED_PER_SQL.put(sql, connectionCount--);

        connectionsAlive--;

        List\<Sample\> timestamps = TRANSACTION_DURATION.get(sql);

        if (   (timestamps != null)
            && (timestamps.size() > 0))
        {
            Sample sample = timestamps.get(timestamps.size() - 1);
            sample.close();
        }
    }

    /**
     * Annotates an operation on the persistence
     * layer takes place.
     * @param sql the sql sentence.
     * @param parameters the sql parameters.
     */
    public synchronized void annotateStatementPrepared(
        <notnull()>final String sql)
    {
        int statementCount = STATEMENTS_OPENED_PER_SQL.get(sql);

        STATEMENTS_OPENED_PER_SQL.put(sql, statementCount++);

        statementsAlive++;

        List\<Sample\> timestamps = SQL_DURATION.get(sql);

        if (timestamps == null)
        {
            timestamps = new ArrayList\<Sample\>();
            timestamps.add(new Sample());
            SQL_DURATION.put(sql, timestamps);
        }
        // else log warning since it is already opened!
    }

    /**
     * Annotates a statement is released.
     * @param sql the SQL sentence.
     * @param preparedStatementCreator the statement creator.
     */
    public synchronized void annotateStatementReleased(
        <notnull()>final String sql)
    {
        int statementCount = STATEMENTS_OPENED_PER_SQL.get(sql);

        STATEMENTS_OPENED_PER_SQL.put(sql, statementCount--);

        statementsAlive--;

        List\<Sample\> timestamps = SQL_DURATION.get(sql);

        if (   (timestamps != null)
            && (timestamps.size() > 0))
        {
            Sample sample = timestamps.get(timestamps.size() - 1);
            sample.close();
        }
    }

    /**
     * Annotates a result-set moves forward one row.
     * @param sql the sql.
     * @param rowCount the number of rows retrieved so far.
     */
    public synchronized void annotateResultSetMovedForward(
        <notnull()>final String sql, final int rowCount)
    {
        ROWS_RETRIEVED_PER_SQL.put(sql, rowCount);

        if (rowCount == 1)
        {
            resultSetsAlive++;

            List\<Sample\> timestamps = ROW_RETRIEVAL_DURATION.get(sql);

            if (timestamps == null)
            {
                timestamps = new ArrayList\<Sample\>();
                timestamps.add(new Sample());
                ROW_RETRIEVAL_DURATION.put(sql, timestamps);
            }
        }
    }

    /**
     * Annotates a result-set is closed.
     * @param sql the sql.
     * @param rowCount the number of rows retrieved.
     */
    public void annotateResultSetClosed(
        <notnull()>final String sql, final int rowCount)
    {
        resultSetsAlive--;

        List\<Sample\> timestamps = ROW_RETRIEVAL_DURATION.get(sql);

        if (   (timestamps != null)
            && (timestamps.size() > 0))
        {
            Sample sample = timestamps.get(timestamps.size() - 1);
            sample.close();
        }
    }

    /**
     * Retrieves the number of currently opened connections.
     * @return such information.
     */
    public int getNumberOfCurrentlyOpenedConnections()
    {
        return connectionsAlive;
    }

    /**
     * Retrieves the number of currently opened statements.
     * @return such information.
     */
    public int getNumberOfCurrentlyOpenedStatements()
    {
        return statementsAlive;
    }

    /**
     * Retrieves the number of currently opened result sets.
     * @return such information.
     */
    public int getNumberOfCurrentlyOpenedResultSets()
    {
        return resultSetsAlive;
    }

    /**
     * Retrieves all annotated SQL queries.
     * @return such list.
     */
    public List\<String\> getSqlList()
    {
        return new ArrayList\<String\>(CONNECTIONS_OPENED_PER_SQL.keySet());
    }

    /**
     * Retrieves the average transaction time for a given SQL query.
     * @param sql the SQL.
     * @return the average transaction time.
     */
    public long getAverageTransactionTime(<notnull()> final String sql)
    {
        long result = 0;

        List\<Sample\> transactionSamples = TRANSACTION_DURATION.get(sql);

        if (transactionSamples != null)
        {
            result = computeAverage(transactionSamples);
        }

        return result;
    }

    /**
     * Retrieves the maximum transaction time for a given SQL query.
     * @param sql the SQL.
     * @return the maximum transaction time.
     */
    public long getMaxTransactionTime(<notnull()> final String sql)
    {
        long result = 0;

        List\<Sample\> transactionSamples = TRANSACTION_DURATION.get(sql);

        if (transactionSamples != null)
        {
            result = computeMax(transactionSamples);
        }

        return result;
    }

    /**
     * Retrieves the minimum transaction time for a given SQL query.
     * @param sql the SQL.
     * @return the minimum transaction time.
     */
    public long getMinTransactionTime(<notnull()> final String sql)
    {
        long result = 0;

        List\<Sample\> transactionSamples = TRANSACTION_DURATION.get(sql);

        if (transactionSamples != null)
        {
            result = computeMin(transactionSamples);
        }

        return result;
    }

    /**
     * Retrieves the average statement time for a given SQL query.
     * @param sql the SQL.
     * @return the average statement time.
     */
    public long getAverageStatementTime(<notnull()> final String sql)
    {
        long result = 0;

        List\<Sample\> transactionSamples = SQL_DURATION.get(sql);

        if (transactionSamples != null)
        {
            result = computeAverage(transactionSamples);
        }

        return result;
    }

    /**
     * Retrieves the maximum statement time for a given SQL query.
     * @param sql the SQL.
     * @return the maximum statement time.
     */
    public long getMaxStatementTime(<notnull()> final String sql)
    {
        long result = 0;

        List\<Sample\> transactionSamples = SQL_DURATION.get(sql);

        if (transactionSamples != null)
        {
            result = computeMax(transactionSamples);
        }

        return result;
    }

    /**
     * Retrieves the minimum statement time for a given SQL query.
     * @param sql the SQL.
     * @return the minimum statement time.
     */
    public long getMinStatementTime(<notnull()> final String sql)
    {
        long result = 0;

        List\<Sample\> transactionSamples = SQL_DURATION.get(sql);

        if (transactionSamples != null)
        {
            result = computeMin(transactionSamples);
        }

        return result;
    }

    /**
     * Retrieves the average result-set time for a given SQL query.
     * @param sql the SQL.
     * @return the average result-set time.
     */
    public long getAverageResultSetTime(<notnull()> final String sql)
    {
        long result = 0;

        List\<Sample\> transactionSamples = ROW_RETRIEVAL_DURATION.get(sql);

        if (transactionSamples != null)
        {
            result = computeAverage(transactionSamples);
        }

        return result;
    }

    /**
     * Retrieves the maximum result-set time for a given SQL query.
     * @param sql the SQL.
     * @return the maximum result-set time.
     */
    public long getMaxResultSetTime(<notnull()> final String sql)
    {
        long result = 0;

        List\<Sample\> transactionSamples = ROW_RETRIEVAL_DURATION.get(sql);

        if (transactionSamples != null)
        {
            result = computeMax(transactionSamples);
        }

        return result;
    }

    /**
     * Retrieves the minimum result-set time for a given SQL query.
     * @param sql the SQL.
     * @return the minimum result-set time.
     */
    public long getMinResultSetTime(<notnull()> final String sql)
    {
        long result = 0;

        List\<Sample\> transactionSamples = ROW_RETRIEVAL_DURATION.get(sql);

        if (transactionSamples != null)
        {
            result = computeMin(transactionSamples);
        }

        return result;
    }

    /**
     * Computes the average of given samples.
     * @param samples the samples.
     * @return the average.
     */
    protected long computeAverage(<notnull()>final List\<Sample\> samples)
    {
        long result = 0;

        int count = samples.size();

        if (count > 0)
        {
            int sum = 0;

            for (<nullable()>Sample sample : samples)
            {
                if (sample != null)
                {
                    sum += sample.getDuration();
                }
            }

            result = sum / count;
        }
        
        return result;
    }

    /**
     * Computes the max of given samples.
     * @param samples the samples.
     * @return the average.
     */
    protected long computeMax(<notnull()>final List\<Sample\> samples)
    {
        long result = 0;

        int count = samples.size();

        if (count > 0)
        {
            long duration = 0;

            for (<nullable()>Sample sample : samples)
            {
                if (sample != null)
                {
                    duration = sample.getDuration();

                    if (duration \> result)
                    {
                        result = duration;
                    }
                }
            }
        }
        
        return result;
    }

    /**
     * Computes the max of given samples.
     * @param samples the samples.
     * @return the average.
     */
    protected long computeMin(<notnull()>final List\<Sample\> samples)
    {
        long result = 0;

        int count = samples.size();

        if (count > 0)
        {
            long duration = 0;

            for (<nullable()>Sample sample : samples)
            {
                if (sample != null)
                {
                    duration = sample.getDuration();

                    if (duration \< result)
                    {
                        result = duration;
                    }
                }
            }
        }
        
        return result;
    }
}
>>
