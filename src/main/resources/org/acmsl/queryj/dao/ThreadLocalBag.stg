//;-*- mode: antlr -*-
//
//                      QueryJ
//
//  Copyright (C) 2002-today  ACM-SL
//                           chous@acm-sl.org
//
//  This library is free software; you can redistribute it and/or
//  modify it under the terms of the GNU General Public
//  License as published by the Free Software Foundation; either
//  version 2 of the License, or any later version.
//
//  This library is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//  General Public License for more details.
//
//  You should have received a copy of the GNU General Public
//  License along with this library; if not, write to the Free Software
//  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
//
//  Thanks to ACM S.L. for distributing this library under the GPL license.
//  Contact info: jose.sanleandro@acm-sl.com
//  Postal Address: c/Playa de Lagoa, 1
//                  Urb. Valdecabanas
//                  Boadilla del monte
//                  28660 Madrid
//                  Spain
//
//***************************************************************************
//
// Filename: ThreadLocalBag.stg
//
// Author: Jose San Leandro Armendariz
//
// Description: Generates ThreadLocalBag sources.
//
group ThreadLocalBag;

source() ::= <<
<!
  Generates a ThreadLocalBag source.
  @param copyright_years the copyright's years.
  @param package the package.
  @params class
!>
<if(header)>
<header>
<else>
<java_header(
  years=copyright_years,
  description=
  [
    first_line_description()
  ],
  timestamp=timestamp)>
<endif>
// Generated by org/acmsl/queryj/dao/ThreadLocalBag.stg at <timestamp>

<package_declaration(
  packageNames=
  [
    project_package,
    typeInitMap.baseDAOSubpackageName,
    typeInitMap.rdbSubpackageName
  ])>

/*
 * Importing some JDK classes.
 */
import java.util.ArrayList;
import java.util.Collection;
import java.util.Date;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Set;

<class()>
>>

first_line_description() ::= <<
<!
  Generates a description for the generated file.
!>
Provides per-thread data containers.
>>

class() ::= <<
<!
 Generates the class body.
!>
/**
 * <[
      first_line_description()
    ]:{line |<line>}; separator="\n * ">
<class_common_javadoc(template="org/acmsl/queryj/dao/ThreadLocalBag.stg")>
 */
<class_annotations()>
public class <repository.capitalized>ThreadLocalBag
{
    /**
     * The key to access the remote IP associated to the thread.
     */
    public static final String REMOTE_IP = "ip";

    /**
     * The key to access the accessed url associated the thread.
     */
    public static final String URL = "url";

    /**
     * The key to access the principal (logged-in user).
     */
    public static final String PRINCIPAL = "principal";

    /**
     * The Map associated to this thread.
     */
    private static final ThreadLocal THREAD_BAG =
        new ThreadLocal()
        {
            /**
             * Retrieves the thread bag.
             * @return such data.
             */
            @SuppressWarnings("unchecked")
            protected synchronized Object initialValue()
            {
                return
                    new KeyBoundedMapDecorator(new HashMap(), 100);
            }
        };

    /**
     * Retrieves the current threads' bag.
     * @return such bag.
     */
    @SuppressWarnings("unchecked")
    public static Map getThreadBag()
    {
        return (Map) THREAD_BAG.get();
    }

    /**
     * Resets the current thread's bag.
     */
    public static void resetThreadBag()
    {
        THREAD_BAG.set(null);
    }

    /**
     * A map whose keys are limited in number.
    <class_common_javadoc(template="org/acmsl/queryj/dao/ThreadLocalBag.stg")>
     */
    public abstract static class AbstractMapDecorator
        implements  Map
    {
        /**
         * The actual map.
         */
        private Map m__DecoratedMap;

        /**
         * Builds an {@link AbstractMapDecorator} instance.
         * @param map the map to decorate.
         */
        public AbstractMapDecorator(<notnull()>final Map map)
        {
            immutableSetDecoratedMap(map);
        }

        /**
         * Specifies the decorated map.
         * @param map such map.
         */
        protected final void immutableSetDecoratedMap(<notnull()>final Map map)
        {
            m__DecoratedMap = map;
        }

        /**
         * Specifies the decorated map.
         * @param map such map.
         */
        protected void setDecoratedMap(<notnull()>final Map map)
        {
            immutableSetDecoratedMap(map);
        }

        /**
         * Retrieves the decorated map.
         * @return such map.
         */
        <notnull()>
        public Map getDecoratedMap()
        {
            return m__DecoratedMap;
        }

        /**
         * Returns the size of the decorated map.
         *
         * @return such information.
         */
        @Override
        public int size()
        {
            return size(getDecoratedMap());
        }

        /**
         * Returns the size of the decorated map.
         * @param decoratedMap the decorated map.
         * @return such information.
         */
        protected int size(<notnull()>final Map decoratedMap)
        {
            return decoratedMap.size();
        }

        /**
         * Checks whether the decorated map is empty.
         * @return \<tt>true\</tt> in such case.
         */
        @Override
        public boolean isEmpty()
        {
            return isEmpty(getDecoratedMap());
        }
    
        /**
         * Checks whether the decorated map is empty.
         * @param decoratedMap the decorated map.
         * @return \<tt>true\</tt> in such case.
         */
        protected boolean isEmpty(<notnull()>final Map decoratedMap)
        {
            return decoratedMap.isEmpty();
        }
    
        /**
         * Checks whether the decorated map contains given key.
         * @param key key whose presence in this map is to be tested.
         * @return \<tt>true\</tt> in such case.
         * 
         * @throws ClassCastException if the key is of an inappropriate type for
         *           this map (optional).
         * @throws NullPointerException if the key is \<tt>null\</tt> and this map
         *            does not permit \<tt>null\</tt> keys (optional).
         */
        @Override
        public boolean containsKey(<notnull()>final Object key)
        {
            return containsKey(key, getDecoratedMap());
        }

        /**
         * Checks whether the decorated map contains given key.
         * @param decoratedMap the decorated map.
         * @param key key whose presence in this map is to be tested.
         * @return \<tt>true\</tt> in such case.
         * 
         * @throws ClassCastException if the key is of an inappropriate type for
         *           this map (optional).
         * @throws NullPointerException if the key is \<tt>null\</tt> and this map
         *            does not permit \<tt>null\</tt> keys (optional).
         */
        protected boolean containsKey(
            <notnull()>final Object key, <notnull()>final Map decoratedMap)
        {
            return decoratedMap.containsKey(key);
        }

        /**
         * Checks whether the decorated map contains given value.
         * @param value value whose presence in this map is to be tested.
         * @return \<tt>true\</tt> in such case.
         * @throws ClassCastException if the value is of an inappropriate type for
         *           this map (optional).
         * @throws NullPointerException if the value is \<tt>null\</tt> and this map
         *            does not permit \<tt>null\</tt> values (optional).
         */
        @Override
        public boolean containsValue(<notnull()>final Object value)
        {
            return containsValue(value, getDecoratedMap());
        }

        /**
         * Checks whether the decorated map contains given value.
         * @param value value whose presence in this map is to be tested.
         * @return \<tt>true\</tt> in such case.
         * @throws ClassCastException if the value is of an inappropriate type for
         *           this map (optional).
         * @throws NullPointerException if the value is \<tt>null\</tt> and this map
         *            does not permit \<tt>null\</tt> values (optional).
         */
        protected boolean containsValue(
            <notnull()>final Object value, <notnull()>final Map decoratedMap)
        {
            return decoratedMap.containsValue(value);
        }

        /**
         * Retrieves the value associated to given key in the decorated map.
         * @param key key whose associated value is to be returned.
         * @return the value to which this map maps the specified key, or
         * \<tt>null\</tt> if the decorated map contains no mappingfor this key.
         * 
         * @throws ClassCastException if the key is of an inappropriate type for
         *           this map (optional).
         * @throws NullPointerException if the key is \<tt>null\</tt> and this map
         *          does not permit \<tt>null\</tt> keys (optional).
         * 
         */
        @Override
        public Object get(<notnull()>final Object key)
        {
            return get(key, getDecoratedMap());
        }
    
        /**
         * Retrieves the value associated to given key in the decorated map.
         * @param key key whose associated value is to be returned.
         * @return the value to which this map maps the specified key, or
         * \<tt>null\</tt> if the decorated map contains no mappingfor this key.
         * 
         * @throws ClassCastException if the key is of an inappropriate type for
         *           this map (optional).
         * @throws NullPointerException if the key is \<tt>null\</tt> and this map
         *          does not permit \<tt>null\</tt> keys (optional).
         * 
         */
        protected Object get(<notnull()>final Object key, <notnull()>final Map decoratedMap)
        {
            return decoratedMap.get(key);
        }
    
        // Modification Operations
    
        /**
         * Associates the specified value with the specified key in the decorated map
         * (optional operation).  If the map previously contained a mapping for
         * this key, the old value is replaced by the specified value. 
         *
         * @param key key with which the specified value is to be associated.
         * @param value value to be associated with the specified key.
         * @return previous value associated with specified key, or \<tt>null\</tt>
         *           if there was no mapping for key.  A \<tt>null\</tt> return can
         *           also indicate that the map previously associated \<tt>null\</tt>
         *           with the specified key, if the implementation supports
         *           \<tt>null\</tt> values.
         * 
         * @throws UnsupportedOperationException if the \<tt>put\</tt> operation is
         *              not supported by this map.
         * @throws ClassCastException if the class of the specified key or value
         *               prevents it from being stored in this map.
         * @throws IllegalArgumentException if some aspect of this key or value
         *              prevents it from being stored in this map.
         * @throws NullPointerException if this map does not permit \<tt>null\</tt>
         *            keys or values, and the specified key or value is
         *            \<tt>null\</tt>.
         */
        @Override
        <nullable()>
        public Object put(<notnull()>final Object key, <notnull()>final Object value)
        {
            return put(key, value, getDecoratedMap());
        }
    
        /**
         * Associates the specified value with the specified key in the decorated map
         * (optional operation).  If the map previously contained a mapping for
         * this key, the old value is replaced by the specified value. 
         *
         * @param key key with which the specified value is to be associated.
         * @param value value to be associated with the specified key.
         * @param decoratedMap the decorated map.
         * @return previous value associated with specified key, or \<tt>null\</tt>
         *           if there was no mapping for key.  A \<tt>null\</tt> return can
         *           also indicate that the map previously associated \<tt>null\</tt>
         *           with the specified key, if the implementation supports
         *           \<tt>null\</tt> values.
         * 
         * @throws UnsupportedOperationException if the \<tt>put\</tt> operation is
         *              not supported by this map.
         * @throws ClassCastException if the class of the specified key or value
         *               prevents it from being stored in this map.
         * @throws IllegalArgumentException if some aspect of this key or value
         *              prevents it from being stored in this map.
         * @throws NullPointerException if this map does not permit \<tt>null\</tt>
         *            keys or values, and the specified key or value is
         *            \<tt>null\</tt>.
         */
        <nullable()>
        protected Object put(
            <notnull()>final Object key,
            <notnull()>final Object value,
            <notnull()>final Map decoratedMap)
        {
            return decoratedMap.put(key, value);
        }
    
        /**
         * Removes the mapping for this key from this map if it is present
         * (optional operation).
         *
         * Returns the value to which the decorated map previously associated the key, or
         * \<tt>null\</tt> if the map contained no mapping for this key.  (A
         * \<tt>null\</tt> return can also indicate that the map previously
         * associated \<tt>null\</tt> with the specified key if the implementation
         * supports \<tt>null\</tt> values.)  The map will not contain a mapping for
         * the specified  key once the call returns.
         *
         * @param key key whose mapping is to be removed from the map.
         * @return previous value associated with specified key, or \<tt>null\</tt>
         *           if there was no mapping for key.
         *
         * @throws ClassCastException if the key is of an inappropriate type for
         *           this map (optional).
         * @throws NullPointerException if the key is \<tt>null\</tt> and this map
         *            does not permit \<tt>null\</tt> keys (optional).
         * @throws UnsupportedOperationException if the \<tt>remove\</tt> method is
         *         not supported by this map.
         */
        @Override
        <nullable()>
        public Object remove(<notnull()>final Object key)
        {
            return remove(key, getDecoratedMap());
        }
    
        /**
         * Removes the mapping for this key from this map if it is present
         * (optional operation).
         *
         * Returns the value to which the decorated map previously associated the key, or
         * \<tt>null\</tt> if the map contained no mapping for this key.  (A
         * \<tt>null\</tt> return can also indicate that the map previously
         * associated \<tt>null\</tt> with the specified key if the implementation
         * supports \<tt>null\</tt> values.)  The map will not contain a mapping for
         * the specified  key once the call returns.
         *
         * @param key key whose mapping is to be removed from the map.
         * @param decoratedMap the decorated map.
         * @return previous value associated with specified key, or \<tt>null\</tt>
         *           if there was no mapping for key.
         *
         * @throws ClassCastException if the key is of an inappropriate type for
         *           this map (optional).
         * @throws NullPointerException if the key is \<tt>null\</tt> and this map
         *            does not permit \<tt>null\</tt> keys (optional).
         * @throws UnsupportedOperationException if the \<tt>remove\</tt> method is
         *         not supported by this map.
         */
        <nullable()>
        protected Object remove(
            <notnull()>final Object key, <notnull()>final Map decoratedMap)
        {
            return decoratedMap.remove(key);
        }
    
    
        // Bulk Operations
    
        /**
         * Copies all of the mappings from the specified map to the decorated map
         * (optional operation). The behavior of this operation is unspecified if the
         * specified map is modified while the operation is in progress.
         *
         * @param t Mappings to be stored in this map.
         * 
         * @throws UnsupportedOperationException if the \<tt>putAll\</tt> method is
         *           not supported by this map.
         * 
         * @throws ClassCastException if the class of a key or value in the
         *               specified map prevents it from being stored in this map.
         * 
         * @throws IllegalArgumentException some aspect of a key or value in the
         *              specified map prevents it from being stored in this map.
         * @throws NullPointerException if the specified map is \<tt>null\</tt>, or if
         *         this map does not permit \<tt>null\</tt> keys or values, and the
         *         specified map contains \<tt>null\</tt> keys or values.
         */
        @Override
        public void putAll(<notnull()>final Map t)
        {
            putAll(t, getDecoratedMap());
        }
    
        /**
         * Copies all of the mappings from the specified map to the decorated map
         * (optional operation). The behavior of this operation is unspecified if the
         * specified map is modified while the operation is in progress.
         *
         * @param t Mappings to be stored in this map.
         * @param decoratedMap the decorated map.
         * @throws UnsupportedOperationException if the \<tt>putAll\</tt> method is
         *           not supported by this map.
         * 
         * @throws ClassCastException if the class of a key or value in the
         *               specified map prevents it from being stored in this map.
         * 
         * @throws IllegalArgumentException some aspect of a key or value in the
         *              specified map prevents it from being stored in this map.
         * @throws NullPointerException if the specified map is \<tt>null\</tt>, or if
         *         this map does not permit \<tt>null\</tt> keys or values, and the
         *         specified map contains \<tt>null\</tt> keys or values.
         */
        @SuppressWarnings("unchecked")
        protected void putAll(
            <notnull()>final Map t, <notnull()>final Map decoratedMap)
        {
            decoratedMap.putAll(t);
        }
    
        /**
         * Removes all mappings from the decorated map (optional operation).
         *
         * @throws UnsupportedOperationException clear is not supported by this
         *           map.
         */
        @Override
        public void clear()
        {
            clear(getDecoratedMap());
        }
    
        /**
         * Removes all mappings from the decorated map (optional operation).
         *
         * @param decoratedMap the decorated map.
         * @throws UnsupportedOperationException clear is not supported by this
         *           map.
         */
        protected void clear(<notnull()>final Map decoratedMap)
        {
            decoratedMap.clear();
        }
    
        // Views
    
        /**
         * Returns a set view of the keys contained in the decorated map.
         * Note: the keys retrieved are not monitored, so changes in this set
         * would not be taken into account (regarding bound checking) until
         * the map changes using Map standard interface.
         * @return a set view of the keys contained in such map.
         */
        @Override
        <notnull()>
        public Set keySet()
        {
            return getKeySet(getDecoratedMap()); 
        }

        /**
         * Returns a set view of the keys contained in the decorated map.
         * @param decoratedMap the decorated map.
         * @return a set view of the keys contained in such map.
         */
        @SuppressWarnings("unchecked")
        <notnull()>
        protected Set getKeySet(<notnull()>final Map decoratedMap)
        {
            return decoratedMap.keySet();
        }

        /**
         * Returns a collection view of the values contained in the decorated map.
         * @return a collection view of the values contained in such map.
         */
        @Override
        @SuppressWarnings("unchecked")
        <notnull()>
        public Collection values()
        {
            return getValues(getDecoratedMap());
        }
    
        /**
         * Returns a collection view of the values contained in the decorated map.
         * @param decoratedMap the decorated map.
         * @return a collection view of the values contained in such map.
         */
        @SuppressWarnings("unchecked")
        <notnull()>
        protected Collection getValues(<notnull()>final Map decoratedMap)
        {
            return decoratedMap.values();
        }
    
        /**
         * Returns a set view of the mappings contained in the decorated map.
         * Note: the keys retrieved are not monitored, so changes in this set
         * would not be taken into account (regarding bound checking) until
         * the map changes using Map standard interface.
         * @return a set view of the mappings contained in such map.
         */
        @Override
        <notnull()>
        public Set entrySet()
        {
            return getEntrySet(getDecoratedMap());
        }

        /**
         * Returns a set view of the mappings contained in the decorated map.
         * @return a set view of the mappings contained in such map.
         */
        <notnull()>
        protected Set getEntrySet(<notnull()>final Map decoratedMap)
        {
            return decoratedMap.entrySet();
        }

        // Comparison and hashing
    
        /**
         * Compares the specified object with the decorated map for equality.
         * @param o object to be compared for equality with such map.
         * @return \<tt>true\</tt> if the specified object is equal to this map.
         */
        @Override
        public boolean equals(<nullable()>final Object o)
        {
            return areEqual(o, getDecoratedMap());
        }
    
        /**
         * Compares the specified object with the decorated map for equality.
         * @param o object to be compared for equality with such map.
         * @param decoratedMap the decorated map.
         * @return \<tt>true\</tt> if the specified object is equal to this map.
         */
        protected boolean areEqual(
            <nullable()>final Object o, <notnull()>final Map decoratedMap)
        {
            return decoratedMap.equals(o);
        }
    
        /**
         * Returns the hash code value of the decorated instance.
         *
         * @return such hash code value.
         */
        @Override
        public int hashCode()
        {
            return getHashCode(getDecoratedMap());
        }

        /**
         * Returns the hash code value of the decorated instance.
         * @param decoratedMap the decorated map.
         * @return such hash code value.
         */
        protected int getHashCode(<notnull()>final Map decoratedMap)
        {
            return decoratedMap.hashCode();
        }
    }

    /**
     * A map whose keys are limited in number.
    <class_common_javadoc(template="org/acmsl/queryj/dao/ThreadLocalBag.stg")>
     */
    public static class KeyBoundedMapDecorator
        extends  AbstractMapDecorator
    {
        /**
         * The max size.
         */
        private int m__iMaxSize;

        /**
         * A list with the map keys, ordered by insertion time.
         */
        private List m__lKeys;

        /**
         * Builds a {@link BoundedMapDecorator} instance.
         * @param map the map to decorate.
         * @param size the upper bound.
         */
        public KeyBoundedMapDecorator(
            <notnull()>final Map map, final int size)
        {
            super(map);
            immutableSetMaxSize(size);
            immutableSetKeyList(new ArrayList());
        }

        /**
         * Specifies the max size.
         * @param size such information.
         */
        protected final void immutableSetMaxSize(<notnull()>final int size)
        {
            m__iMaxSize = size;
        }

        /**
         * Specifies the max size.
         * @param size such information.
         */
        @SuppressWarnings("unused")
        protected void setMaxSize(final int size)
        {
            immutableSetMaxSize(size);
        }

        /**
         * Retrieves the max size.
         * @return such information.
         */
        public int getMaxSize()
        {
            return m__iMaxSize;
        }

        /**
         * Specifies the key list.
         * @param list such list.
         */
        protected final void immutableSetKeyList(<notnull()>final List list)
        {
            m__lKeys = list;
        }

        /**
         * Specifies the key list.
         * @param list such list.
         */
        @SuppressWarnings("unused")
        protected void setKeyList(<notnull()>final List list)
        {
            immutableSetKeyList(list);
        }

        /**
         * Retrieves the key list.
         * @return such list.
         */
        <notnull()>
        public List getKeyList()
        {
            return m__lKeys;
        }
    
        // Modification Operations
    
        /**
         * Associates the specified value with the specified key in the decorated map
         * (optional operation).  If the map previously contained a mapping for
         * this key, the old value is replaced by the specified value. 
         *
         * @param key key with which the specified value is to be associated.
         * @param value value to be associated with the specified key.
         * @return previous value associated with specified key, or \<tt>null\</tt>
         *           if there was no mapping for key.  A \<tt>null\</tt> return can
         *           also indicate that the map previously associated \<tt>null\</tt>
         *           with the specified key, if the implementation supports
         *           \<tt>null\</tt> values.
         * 
         * @throws UnsupportedOperationException if the \<tt>put\</tt> operation is
         *              not supported by this map.
         * @throws ClassCastException if the class of the specified key or value
         *               prevents it from being stored in this map.
         * @throws IllegalArgumentException if some aspect of this key or value
         *              prevents it from being stored in this map.
         * @throws NullPointerException if this map does not permit \<tt>null\</tt>
         *            keys or values, and the specified key or value is
         *            \<tt>null\</tt>.
         */
        @Override
        <nullable()>
        public Object put(<notnull()>final Object key, <notnull()>final Object value)
        {
            return put(key, value, getDecoratedMap(), getMaxSize(), getKeyList());
        }
    
        /**
         * Associates the specified value with the specified key in the decorated map
         * (optional operation).  If the map previously contained a mapping for
         * this key, the old value is replaced by the specified value. 
         *
         * @param key key with which the specified value is to be associated.
         * @param value value to be associated with the specified key.
         * @param decoratedMap the decorated map.
         * @param maxSize the maximum size of the map.
         * @param keyList the key list.
         * @return previous value associated with specified key, or \<tt>null\</tt>
         *           if there was no mapping for key.  A \<tt>null\</tt> return can
         *           also indicate that the map previously associated \<tt>null\</tt>
         *           with the specified key, if the implementation supports
         *           \<tt>null\</tt> values.
         * 
         * @throws UnsupportedOperationException if the \<tt>put\</tt> operation is
         *              not supported by this map.
         * @throws ClassCastException if the class of the specified key or value
         *               prevents it from being stored in this map.
         * @throws IllegalArgumentException if some aspect of this key or value
         *              prevents it from being stored in this map.
         * @throws NullPointerException if this map does not permit \<tt>null\</tt>
         *            keys or values, and the specified key or value is
         *            \<tt>null\</tt>.
         */
        @SuppressWarnings("unchecked")
        <nullable()>
        protected Object put(
            <notnull()>final Object key,
            <notnull()>final Object value,
            <notnull()>final Map decoratedMap,
            final int maxSize,
            <notnull()>final List keyList)
        {
            Object result = decoratedMap.put(key, value);

            if  (keyList.contains(key))
            {
                // Put the key as the newest item.
                keyList.remove(key);
            }

            keyList.add(key);

            if  (keyList.size() > maxSize)
            {
                Object t_OldestKey = keyList.get(0);

                if  (t_OldestKey != null)
                {
                    decoratedMap.remove(t_OldestKey);
                }

                keyList.remove(0);
            }

            return result;
        }
    
        /**
         * Removes the mapping for this key from this map if it is present
         * (optional operation).
         *
         * Returns the value to which the decorated map previously associated the key, or
         * \<tt>null\</tt> if the map contained no mapping for this key.  (A
         * \<tt>null\</tt> return can also indicate that the map previously
         * associated \<tt>null\</tt> with the specified key if the implementation
         * supports \<tt>null\</tt> values.)  The map will not contain a mapping for
         * the specified  key once the call returns.
         *
         * @param key key whose mapping is to be removed from the map.
         * @return previous value associated with specified key, or \<tt>null\</tt>
         *           if there was no mapping for key.
         *
         * @throws ClassCastException if the key is of an inappropriate type for
         *           this map (optional).
         * @throws NullPointerException if the key is \<tt>null\</tt> and this map
         *            does not permit \<tt>null\</tt> keys (optional).
         * @throws UnsupportedOperationException if the \<tt>remove\</tt> method is
         *         not supported by this map.
         */
        @Override
        <nullable()>
        public Object remove(<notnull()>final Object key)
        {
            return remove(key, getDecoratedMap(), getKeyList());
        }
    
        /**
         * Removes the mapping for this key from this map if it is present
         * (optional operation).
         *
         * Returns the value to which the decorated map previously associated the key, or
         * \<tt>null\</tt> if the map contained no mapping for this key.  (A
         * \<tt>null\</tt> return can also indicate that the map previously
         * associated \<tt>null\</tt> with the specified key if the implementation
         * supports \<tt>null\</tt> values.)  The map will not contain a mapping for
         * the specified  key once the call returns.
         *
         * @param key key whose mapping is to be removed from the map.
         * @param decoratedMap the decorated map.
         * @param keyList the key list.
         * @return previous value associated with specified key, or \<tt>null\</tt>
         *           if there was no mapping for key.
         *
         * @throws ClassCastException if the key is of an inappropriate type for
         *           this map (optional).
         * @throws NullPointerException if the key is \<tt>null\</tt> and this map
         *            does not permit \<tt>null\</tt> keys (optional).
         * @throws UnsupportedOperationException if the \<tt>remove\</tt> method is
         *         not supported by this map.
         */
        @SuppressWarnings("unchecked")
        <nullable()>
        protected Object remove(
            <notnull()>final Object key,
            <notnull()>final Map decoratedMap,
            <notnull()>final List keyList)
        {
            Object result = decoratedMap.remove(key);

            keyList.remove(key);

            return result;
        }
    
    
        // Bulk Operations
    
        /**
         * Copies all of the mappings from the specified map to the decorated map
         * (optional operation). The behavior of this operation is unspecified if the
         * specified map is modified while the operation is in progress.
         *
         * @param t Mappings to be stored in this map.
         * 
         * @throws UnsupportedOperationException if the \<tt>putAll\</tt> method is
         *           not supported by this map.
         * 
         * @throws ClassCastException if the class of a key or value in the
         *               specified map prevents it from being stored in this map.
         * 
         * @throws IllegalArgumentException some aspect of a key or value in the
         *              specified map prevents it from being stored in this map.
         * @throws NullPointerException if the specified map is \<tt>null\</tt>, or if
         *         this map does not permit \<tt>null\</tt> keys or values, and the
         *         specified map contains \<tt>null\</tt> keys or values.
         */
        @Override
        public void putAll(<notnull()>final Map t)
        {
            putAll(t, getDecoratedMap(), getMaxSize(), getKeyList());
        }
    
        /**
         * Copies all of the mappings from the specified map to the decorated map
         * (optional operation). The behavior of this operation is unspecified if the
         * specified map is modified while the operation is in progress.
         *
         * @param t Mappings to be stored in this map.
         * @param decoratedMap the decorated map.
         * @param maxSize the maximum allowed size for the map keys.
         * @param keyList the list of keys.
         * @throws UnsupportedOperationException if the \<tt>putAll\</tt> method is
         *           not supported by this map.
         * 
         * @throws ClassCastException if the class of a key or value in the
         *               specified map prevents it from being stored in this map.
         * 
         * @throws IllegalArgumentException some aspect of a key or value in the
         *              specified map prevents it from being stored in this map.
         * @throws NullPointerException if the specified map is \<tt>null\</tt>, or if
         *         this map does not permit \<tt>null\</tt> keys or values, and the
         *         specified map contains \<tt>null\</tt> keys or values.
         */
        @SuppressWarnings("unchecked")
        protected void putAll(
            <notnull()>final Map t,
            <notnull()>final Map decoratedMap, 
            final int maxSize,
            <notnull()>final List keyList)
        {
            decoratedMap.putAll(t);

            List t_lNewKeyList = keyList;

            t_lNewKeyList.addAll(t.keySet());

            t_lNewKeyList = removeDuplicates(t_lNewKeyList);
            setKeyList(t_lNewKeyList);

            Object lastKey;

            while  (t_lNewKeyList.size() > maxSize)
            {
                lastKey = t_lNewKeyList.remove(0);
                decoratedMap.remove(lastKey);
            }
        }
    
        /**
         * Removes all mappings from the decorated map (optional operation).
         *
         * @throws UnsupportedOperationException clear is not supported by this
         *           map.
         */
        @Override
        public void clear()
        {
            clear(getDecoratedMap(), getKeyList());
        }
    
        /**
         * Removes all mappings from the decorated map (optional operation).
         *
         * @param decoratedMap the decorated map.
         * @param keyList the key list.
         * @throws UnsupportedOperationException clear is not supported by this
         *           map.
         */
        protected void clear(<notnull()>final Map decoratedMap, <notnull()>final List keyList)
        {
            decoratedMap.clear();
            keyList.clear();
        }
    
        /**
         * Removes any duplicated entries in given list.
         * @param list the list.
         * @return the modified list.
         */
        @SuppressWarnings("unchecked")
        <notnull()>
        protected List removeDuplicates(<notnull()>final List list)
        {
            <notnull()>final List result = new ArrayList();

            for (<nullable()> Object item : list)
            {
                if (item != null)
                {
                    while (result.contains(item))
                    {
                        result.remove(item);
                    }
                    result.add(item);
                }
            }

            return result;
        }
    }

    /**
     * A map whose values have an extra timestamp annotation.
    <class_common_javadoc(template="org/acmsl/queryj/dao/ThreadLocalBag.stg")>
     */
    public static class TimestampMapDecorator
        extends  AbstractMapDecorator
    {
        /**
         * The timestamp map.
         */
        private Map m__mTimestamps;

        /**
         * Builds a {@link TimestampMapDecorator} instance.
         * @param map the map to decorate.
         * @param size the upper bound.
         */
        public TimestampMapDecorator(<notnull()>final Map map)
        {
            super(map);
            immutableSetTimestampMap(new HashMap());
        }

        /**
         * Specifies the timestamp map.
         * @param map such map.
         */
        protected final void immutableSetTimestampMap(<notnull()>final Map map)
        {
            m__mTimestamps = map;
        }

        /**
         * Specifies the timestamp map.
         * @param map such map.
         */
        @SuppressWarnings("unused")
        protected void setTimestampMap(<notnull()>final Map map)
        {
            immutableSetTimestampMap(map);
        }

        /**
         * Retrieves the timestamp map.
         * @return such map.
         */
        <notnull()>
        public Map getTimestampMap()
        {
            return m__mTimestamps;
        }

        /**
         * Retrieves the value associated to given key in the decorated map.
         * @param key key whose associated value is to be returned.
         * @return the value to which this map maps the specified key, or
         * \<tt>null\</tt> if the decorated map contains no mappingfor this key.
         * 
         * @throws ClassCastException if the key is of an inappropriate type for
         *           this map (optional).
         * @throws NullPointerException if the key is \<tt>null\</tt> and this map
         *          does not permit \<tt>null\</tt> keys (optional).
         * 
         */
        <nullable()>
        public Date getTimestamp(<notnull()>final Object key)
        {
            return getTimestamp(key, getTimestampMap());
        }
    
        /**
         * Retrieves the timestamp associated to the value referred by given key.
         * @param key key whose associated value is to be returned.
         * @param timestampMap the timestamp map.
         * @return the value to which this map maps the specified key, or
         * \<tt>null\</tt> if the decorated map contains no mappingfor this key.
         * 
         * @throws ClassCastException if the key is of an inappropriate type for
         *           this map (optional).
         * @throws NullPointerException if the key is \<tt>null\</tt> and this map
         *          does not permit \<tt>null\</tt> keys (optional).
         * 
         */
        @SuppressWarnings("unchecked")
        <nullable()>
        protected Date getTimestamp(
            <notnull()>final Object key, <notnull()>final Map timestampMap)
        {
            Date result = null;

            Object t_Value = get(key);

            if  (t_Value != null)
            {
                result =
                    (Date)
                        timestampMap.get(
                            buildTimestampKey(key, t_Value));
            }

            return result;
        }

        /**
         * Builds a timestamp key.
         * @param key the key.
         * @param value the value.
         * @return such key.
         */
        <notnull()>
        protected Object buildTimestampKey(
            <notnull()>final Object key, <notnull()>final Object value)
        {
            return
                "asd3e23::"
                + ((key != null) ? "" + key.hashCode() : "null")
                + "//\\\\"
                + ((value != null) ? "" + value.hashCode() : "null");
        }

        // Modification Operations
    
        /**
         * Associates the specified value with the specified key in the decorated map
         * (optional operation).  If the map previously contained a mapping for
         * this key, the old value is replaced by the specified value. 
         *
         * @param key key with which the specified value is to be associated.
         * @param value value to be associated with the specified key.
         * @return previous value associated with specified key, or \<tt>null\</tt>
         *           if there was no mapping for key.  A \<tt>null\</tt> return can
         *           also indicate that the map previously associated \<tt>null\</tt>
         *           with the specified key, if the implementation supports
         *           \<tt>null\</tt> values.
         * 
         * @throws UnsupportedOperationException if the \<tt>put\</tt> operation is
         *              not supported by this map.
         * @throws ClassCastException if the class of the specified key or value
         *               prevents it from being stored in this map.
         * @throws IllegalArgumentException if some aspect of this key or value
         *              prevents it from being stored in this map.
         * @throws NullPointerException if this map does not permit \<tt>null\</tt>
         *            keys or values, and the specified key or value is
         *            \<tt>null\</tt>.
         */
        @Override
        <nullable()>
        public Object put(<notnull()>final Object key, <notnull()>final Object value)
        {
            return put(key, value, getDecoratedMap(), getTimestampMap());
        }
    
        /**
         * Associates the specified value with the specified key in the decorated map
         * (optional operation).  If the map previously contained a mapping for
         * this key, the old value is replaced by the specified value. 
         *
         * @param key key with which the specified value is to be associated.
         * @param value value to be associated with the specified key.
         * @param decoratedMap the decorated map.
         * @param timestampMap the timestamp map.
         * @return previous value associated with specified key, or \<tt>null\</tt>
         *           if there was no mapping for key.  A \<tt>null\</tt> return can
         *           also indicate that the map previously associated \<tt>null\</tt>
         *           with the specified key, if the implementation supports
         *           \<tt>null\</tt> values.
         * 
         * @throws UnsupportedOperationException if the \<tt>put\</tt> operation is
         *              not supported by this map.
         * @throws ClassCastException if the class of the specified key or value
         *               prevents it from being stored in this map.
         * @throws IllegalArgumentException if some aspect of this key or value
         *              prevents it from being stored in this map.
         * @throws NullPointerException if this map does not permit \<tt>null\</tt>
         *            keys or values, and the specified key or value is
         *            \<tt>null\</tt>.
         */
        @SuppressWarnings("unchecked")
        <nullable()>
        protected Object put(
            <notnull()>final Object key,
            <notnull()>final Object value,
            <notnull()>final Map decoratedMap,
            <notnull()>final Map timestampMap)
        {
            Object result = null;

            Object t_TimestampKey = buildTimestampKey(key, value);

            timestampMap.remove(t_TimestampKey);

            Date t_Timestamp = new Date();

            result = super.put(key, value, decoratedMap);

            timestampMap.put(t_TimestampKey, t_Timestamp);

            return result;
        }
    
        /**
         * Removes the mapping for this key from this map if it is present
         * (optional operation).
         *
         * Returns the value to which the decorated map previously associated the key, or
         * \<tt>null\</tt> if the map contained no mapping for this key.  (A
         * \<tt>null\</tt> return can also indicate that the map previously
         * associated \<tt>null\</tt> with the specified key if the implementation
         * supports \<tt>null\</tt> values.)  The map will not contain a mapping for
         * the specified  key once the call returns.
         *
         * @param key key whose mapping is to be removed from the map.
         * @return previous value associated with specified key, or \<tt>null\</tt>
         *           if there was no mapping for key.
         *
         * @throws ClassCastException if the key is of an inappropriate type for
         *           this map (optional).
         * @throws NullPointerException if the key is \<tt>null\</tt> and this map
         *            does not permit \<tt>null\</tt> keys (optional).
         * @throws UnsupportedOperationException if the \<tt>remove\</tt> method is
         *         not supported by this map.
         */
        @Override
        <nullable()>
        public Object remove(<notnull()>final Object key)
        {
            return remove(key, getDecoratedMap(), getTimestampMap());
        }
    
        /**
         * Removes the mapping for this key from this map if it is present
         * (optional operation).
         *
         * Returns the value to which the decorated map previously associated the key, or
         * \<tt>null\</tt> if the map contained no mapping for this key.  (A
         * \<tt>null\</tt> return can also indicate that the map previously
         * associated \<tt>null\</tt> with the specified key if the implementation
         * supports \<tt>null\</tt> values.)  The map will not contain a mapping for
         * the specified  key once the call returns.
         *
         * @param key key whose mapping is to be removed from the map.
         * @param decoratedMap the decorated map.
         * @param timestampMap the timestamp map.
         * @return previous value associated with specified key, or \<tt>null\</tt>
         *           if there was no mapping for key.
         *
         * @throws ClassCastException if the key is of an inappropriate type for
         *           this map (optional).
         * @throws NullPointerException if the key is \<tt>null\</tt> and this map
         *            does not permit \<tt>null\</tt> keys (optional).
         * @throws UnsupportedOperationException if the \<tt>remove\</tt> method is
         *         not supported by this map.
         */
        <nullable()>
        protected Object remove(
            <notnull()>final Object key,
            <notnull()>final Map decoratedMap,
            <notnull()>final Map timestampMap)
        {
            Object result = super.remove(key, decoratedMap);

            timestampMap.remove(buildTimestampKey(key, result));

            return result;
        }
    
    
        // Bulk Operations
    
        /**
         * Copies all of the mappings from the specified map to the decorated map
         * (optional operation). The behavior of this operation is unspecified if the
         * specified map is modified while the operation is in progress.
         *
         * @param t Mappings to be stored in this map.
         * 
         * @throws UnsupportedOperationException if the \<tt>putAll\</tt> method is
         *           not supported by this map.
         * 
         * @throws ClassCastException if the class of a key or value in the
         *               specified map prevents it from being stored in this map.
         * 
         * @throws IllegalArgumentException some aspect of a key or value in the
         *              specified map prevents it from being stored in this map.
         * @throws NullPointerException if the specified map is \<tt>null\</tt>, or if
         *         this map does not permit \<tt>null\</tt> keys or values, and the
         *         specified map contains \<tt>null\</tt> keys or values.
         */
        @Override
        public void putAll(<notnull()>final Map t)
        {
            putAll(t, getDecoratedMap(), getTimestampMap());
        }
    
        /**
         * Copies all of the mappings from the specified map to the decorated map
         * (optional operation). The behavior of this operation is unspecified if the
         * specified map is modified while the operation is in progress.
         *
         * @param t Mappings to be stored in this map.
         * @param decoratedMap the decorated map.
         * @param timestampMap the timestamp map.
         * @throws UnsupportedOperationException if the \<tt>putAll\</tt> method is
         *           not supported by this map.
         * 
         * @throws ClassCastException if the class of a key or value in the
         *               specified map prevents it from being stored in this map.
         * 
         * @throws IllegalArgumentException some aspect of a key or value in the
         *              specified map prevents it from being stored in this map.
         * @throws NullPointerException if the specified map is \<tt>null\</tt>, or if
         *         this map does not permit \<tt>null\</tt> keys or values, and the
         *         specified map contains \<tt>null\</tt> keys or values.
         */
        @SuppressWarnings("unchecked")
        protected void putAll(
            <notnull()>final Map t,
            <notnull()>final Map decoratedMap, 
            <notnull()>final Map timestampMap)
        {
            Collection t_cKeys = t.keySet();

            Iterator t_itKeys = t_cKeys.iterator();

            Object t_Key;
            Object t_Value;

            while  (t_itKeys.hasNext())
            {
                t_Key = t_itKeys.next();
                put(t_Key, t_itKeys.next(), decoratedMap, timestampMap);
            }
        }
    
        /**
         * Removes all mappings from the decorated map (optional operation).
         *
         * @throws UnsupportedOperationException clear is not supported by this
         *           map.
         */
        @Override
        public void clear()
        {
            clear(getDecoratedMap(), getTimestampMap());
        }
    
        /**
         * Removes all mappings from the decorated map (optional operation).
         *
         * @param decoratedMap the decorated map.
         * @param timestampMap the timestamp map.
         * @throws UnsupportedOperationException clear is not supported by this
         *           map.
         */
        @SuppressWarnings("unchecked")
        protected void clear(
            <notnull()>final Map decoratedMap, <notnull()>final Map timestampMap)
        {
            decoratedMap.clear();
            timestampMap.clear();
        }
    }
}
>>
