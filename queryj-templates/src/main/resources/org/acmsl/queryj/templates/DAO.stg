//;-*- mode: antlr -*-
//
//                      QueryJ
//
//  Copyright (C) 2002-today  ACM-SL
//                           chous@acm-sl.org
//
//  This library is free software; you can redistribute it and/or
//  modify it under the terms of the GNU General Public
//  License as published by the Free Software Foundation; either
//  version 2 of the License, or any later version.
//
//  This library is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//  General Public License for more details.
//
//  You should have received a copy of the GNU General Public
//  License along with this library; if not, write to the Free Software
//  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
//
//  Thanks to ACM S.L. for distributing this library under the GPL license.
//  Contact info: jose.sanleandro@acm-sl.com
//  Postal Address: c/Playa de Lagoa, 1
//                  Urb. Valdecabanas
//                  Boadilla del monte
//                  28660 Madrid
//                  Spain
//
//***************************************************************************
//
// Filename: DAO.stg
//
// Author: Jose San Leandro Armendariz
//
// Description: Defines the rules to generate DAO database-based
//              implementations.
//
group DAO;

import "queryj.stg"

source(C) ::= <<
<!
  Generates a DAO database implementation source file.
!>
<sourceImpl(table=C.table, engine=C.engine, C=C)>
>>

sourceImpl(table, engine, C) ::= <<
<!
  Generates a DAO database implementation source file.
  @param table the table.
  @param C the context.
!>
/*
<if(C.header)>
<C.header>
<else>
<java_header(
  description=
  [
    first_line_description(tableName=table.name, engine=engine),
    second_line_description(tableName=table.name, engine=engine),
    third_line_description(tableName=table.name, engine=engine)
  ],
  template="org/acmsl/queryj/templates/dao/DAO.stg",
  C=C)><endif>
 */
<package_declaration(p=C.package)>

<project_imports(
  basePackageName=C.project_package,
  package=C.package,
  jdbcOperationsSubpackageName=typeInitMap.jdbcOperationsSubpackageName,
  voSubpackageName=typeInitMap.voSubpackageName,
  voName=table.name.voName,
  voFactorySubpackageName=typeInitMap.voFactorySubpackageName,
  rdbSubpackageName=typeInitMap.rdbSubpackageName,
  trSubpackageName=typeInitMap.tableRepositorySubpackageName,
  trName=C.repository.capitalized,
  damSubpackageName=typeInitMap.dataAccessManagerSubpackageName,
  fkssSubpackageName=typeInitMap.foreignKeyStatementSetterSubpackageName,
  fkAttributes=table.foreignKeys,
  baseDAOSubpackageName=typeInitMap.baseDAOSubpackageName,
  table=table,
  parent=table.parentTable)>
/*
 * Importing Spring classes.
 */
import org.springframework.dao.DataAccessException;
import org.springframework.jdbc.core.PreparedStatementCreator;
import org.springframework.jdbc.core.PreparedStatementCreatorFactory;
import org.springframework.jdbc.core.PreparedStatementSetter;
import org.springframework.jdbc.core.ResultSetExtractor;
import org.springframework.jdbc.core.SqlParameter;
import org.springframework.jdbc.datasource.DataSourceTransactionManager;
import org.springframework.transaction.PlatformTransactionManager;
import org.springframework.transaction.support.TransactionTemplate;

/*
 * Importing some JDK classes.
 */
<imports(table=table)>
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Types;
<if(table.static)>
import java.util.ArrayList;
<endif>
import java.util.HashMap;
import java.util.List;
<import_attribute_types(table=table, useHeader=false, nullableOnly=true)>
<table.customSelects:{ cs| <import_custom_select_types(cs=cs, C=C)>}; separator="\n">
import java.util.Map;

/*
 * Importing some JDK extension classes
 */
import javax.sql.DataSource;
<checkers_import(C=C)>

<class(foreign_keys=table.foreignKeys, table=table, engine=engine, C=C)>
>>

imports(table) ::= <<
<!
  Generates the imports for the attributes' types.
  @param table the table.
!>
<table.attributeTypes:{ t | import <t>;} ; separator="\n">
>>

first_line_description(tableName, engine) ::= <<
<!
  Generates a description for the generated file.
  @param tableName the table name.
  @param engine the engine.
!>
DAO implementation responsible of managing the access to <tableName> entities from
>>

second_line_description(tableName, engine) ::= <<
<!
  Generates a description for the generated file.
  @param tableName the table name.
  @param engineName the engine name.
  @param engineVersion the engine version.
!>
entities from <engine.name> <if(engine.version)>(<engine.version>) <endif>persistence layers.
>>

project_imports(
  basePackageName,
  package,
  jdbcOperationsSubpackageName,
  voSubpackageName,
  voName,
  voFactorySubpackageName,
  rdbSubpackageName,
  trSubpackageName,
  trName,
  damSubpackageName,
  fkssSubpackageName,
  fkAttributes,
  baseDAOSubpackageName,
  table,
  parent) ::= <<
<!
  Generates the project imports
  @param basePackageName the base package name.
  @param package the package.
  @param jdbcOperationsSubpackageName the subpackage for the JDBC operations.
  @param voSubpackageName the subpackage for the value
  @param voName the class name of the value-object.
  @param voFactorySubpackageName the subpackage of the value object factories.
  @param rdbSubpackageName the subpackage common of all RDBMs implementations.
  @param trSubpackageName the subpackage of the table repository.
  @param trName the name of the table repository.
  @param damSubpackageName the subpackage of the DataAccessManager.
  @param fkssSubpackageName the subpackage of the foreign key attribute
  statement setter.
  @param fkAttributes the foreign key attributes.
  @param baseDAOSubpackageName the subpackage of the base DAO interface.
  @param table the table.
  @param parent the parent table (optional).
!>
/*
 * Importing <trName> classes.
 */
<if(table.foreignKeys)>
import <basePackageName>.<damSubpackageName>.<trName>DataAccessManager;
<endif>
import <basePackageName>.<baseDAOSubpackageName>.<table.name.voName>DAO;
import <basePackageName>.<baseDAOSubpackageName>.<table.name.voName.lowercased>.<table.name.voName>StatementSetter;
import <basePackageName>.<baseDAOSubpackageName>.<table.name.voName.lowercased>.<table.name.voName>PkStatementSetter;
import <basePackageName>.<baseDAOSubpackageName>.<table.name.voName.lowercased>.<table.name.voName>ResultSetMultipleExtractor;
import <basePackageName>.<baseDAOSubpackageName>.<table.name.voName.lowercased>.<table.name.voName>ResultSetSingleExtractor;
<if(parent)>
import <basePackageName>.<baseDAOSubpackageName>.<parent.name.voName>DAO;
<endif>
import <basePackageName>.<voSubpackageName>.<table.name.voName>;
import <basePackageName>.<voSubpackageName>.impl.<table.name.voName>Impl;
<if(parent)>
import <basePackageName>.<voSubpackageName>.<parent.name.voName>;
<endif>
<if(table.voDecorated)>
import <basePackageName>.<voSubpackageName>.<table.name.voName>Decorator;
<endif>
import <basePackageName>.<voFactorySubpackageName>.core.<table.name.voName>Factory;
<table.foreignKeys:{ fk| <foreignkey_statementsetter_import(
  basePackageName=basePackageName,
  fkssSubpackageName=fkssSubpackageName,
  foreignKey=fk)>}; separator="\n">
<table.foreignKeys:{ fk | <foreignkey_dao_import(
  basePackageName=basePackageName,
  baseDAOSubpackageName=baseDAOSubpackageName,
  referredVOName=fk.source.name.voName)>}; separator="\n">
//<table.customResults>
<table.customResults:{ cr  | <custom_select_return_import(result=cr, package=basePackageName, baseDAOSubpackageName=baseDAOSubpackageName, C=C)>}; separator="\n">

/*
 * Importing V24-Commons classes.
 */
import com.ventura24.commons.dao.DAOListener;
<if(table.customResults)
 ><table.customResults:{ cr  | <if(cr.wrappingASingleProperty)><cr.properties:{p | <if(p.typeSupportedOutOfTheBox)>import com.ventura24.commons.dao.<p.objectType>ResultSetMultipleExtractor;<endif>}; separator="\n"><endif>}; separator="\n">
<endif>
import com.ventura24.commons.dao.V24JdbcTemplate;
import com.ventura24.commons.dao.V24PreparedStatementCreator;
import com.ventura24.commons.dao.V24PreparedStatementSetter;
import com.ventura24.commons.dao.V24QueryTransactionCallback;
//import com.ventura24.commons.dao.V24SelectForUpdateTransactionCallback;
import com.ventura24.commons.dao.V24UpdateTransactionCallback;
import com.ventura24.commons.dao.V24ResultSetSingleExtractor;

>>

foreignkey_statementsetter_import(
  basePackageName,
  fkssSubpackageName,
  foreignKey) ::= <<
<!
  Generates the import statement of a foreign key statement setter.
  @param basePackageName the base package.
  @param fkssSubpackageName the subpackage of the foreign key attribute
  statement setter.
  @param foreignKey the foreign key.
!>
<!//import <basePackageName>.<fkssSubpackageName>.<foreignKey.target.name.name>By<foreignKey.source.name.voName>StatementSetter;!>
>>

foreignkey_dao_import(
  basePackageName,
  baseDAOSubpackageName,
  referredVOName) ::= <<
<!
  Generates the import statement of a foreign key DAO.
  @param baseDAOSubpackageName the subpackage of the base DAO interface.
  @param referredVOName the referred value object name.
!>
import <basePackageName>.<baseDAOSubpackageName>.<referredVOName>DAO;
>>

class(foreign_keys, table, engine, C) ::= <<
<!
 Generates the class body.
 @param engine_name the engine name.
 @param engine_version the engine version.
 @param timestamp the timestamp.
 @param custom_results the results for the custom queries.
 @param repository the table repository name.
 @param table the table.
!>
<classImpl(
    foreign_keys=table.foreignKeys, table=table, parent=table.parentTable, repository=C.repository, engine=engine, C=C)>
>>

classImpl(foreign_keys, table, parent, repository, engine, C) ::= <<
<!
 Generates the class body.
 @param engine_name the engine name.
 @param engine_version the engine version.
 @param timestamp the timestamp.
 @param repository the table repository name.
 @param table the table.
 @param parent the parent table.
!>
/**
 * <[
      first_line_description(tableName=table.name, engine=engine),
      second_line_description(tableName=table.name, engine=engine)
    ]:{line |<line>}; separator="\n * ">
<class_common_javadoc(template="org/acmsl/queryj/templates/dao/DAO.stg", C=C)>
 */
<class_annotations(C=C)>
public <if(table.dynamicQueries)>abstract <endif>class <engine.name><table.name.voName>DAO
  extends     V24JdbcTemplate
  implements  <table.name.voName>DAO
<!//              <repository.capitalized>TableRepository!>
{
<if(table.primaryKey)>
    <find_by_primary_key_sql(table=table, parent=parent, repository=repository, C=C)>

<endif>
    <insert_sql(table=table, parent=parent, repository=repository, C=C)>
    <update_sql(table=table, parent=parent, repository=repository, C=C)>
    <delete_sql(table=table, parent=parent, repository=repository, C=C)>
<if(table.foreignKeys)>

    <table.foreignKeys:{ fk | <delete_by_fk_sql(foreignKey=fk)>}; separator="\n\n">
<endif>
<if(table.customSelects)>
    // custom selects
    <custom_selects_sql(table=table, repository=repository, C=C)>
<endif>
<if(table.customSelectsForUpdate)>

    <custom_selects_for_update_sql(table=table, repository=repository, C=C)>
<endif>
<if(table.customUpdatesOrInserts)>

    <custom_updates_or_inserts_sql(table=table, repository=repository, C=C)>
<endif>
    <constructor(table=table, repository=repository, engine=engine, C=C)>
<if(table.static)>
    /**
     * Retrieves the static (pre-cached) values.
     * @return such information.
     */
    <notnull(C=C)>
    @Override
    public List\<<table.name.voName\>> getStaticValues()
    {
        return FIXED_CONSTANTS;
    }

<if(table.primaryKey)>

    <find_constant_by_pk(primaryKey=table.primaryKey, table=table, C=C)>
<endif>

    <table.own.minus.primaryKey.minus.readOnlyAttributes:{ attr | <find_constant_methods(attribute=attr, table=table, C=C)>}; separator="\n">

<endif>
    <find_by_primary_key(table=table, parent=parent, repository=repository, C=C)>

    <insert(table=table, parent=parent, repository=repository, C=C)>

    <create(table=table, parent=parent, repository=repository, C=C)>

    <update(table=table, parent=parent, repository=repository, C=C)>

    <delete(table=table, parent=parent, repository=repository, C=C)>

    <table.foreignKeys:{ fk | <fk_delete_method(foreignKey=fk, table=table)>}; separator="\n">
<if(table.customSelects)>

    <table.customSelects:{ cs | <custom_select(cs=cs, table=table, C=C)>}; separator="\n">
<endif>
<if(table.customUpdatesOrInserts)>

    <table.customUpdatesOrInserts:{ cs | <custom_update_or_insert(cs=cs, C=C)>}; separator="\n">
<endif>

    <table.externallyManagedAttributes:{ attr | <attribute_resultset_extractor_class(
      table=table, repository=repository, attr=attr, C=C)>}; separator="\n\n">

    <extractors(table=table, parent=parent, repository=repository, C=C)>
}
>>

find_by_primary_key_sql(table, parent, repository, C) ::= <<
<!
 Generates the find-by-primary-key SQL.
 @param table the table.
 @param parent the parent.
 @param repository the repository.
 @param C the context.
 !>

/**
 * The SQL to find by primary key.
 */
public static final String _FIND_BY_PK_SQL =
      "SELECT "
<if(parent)>
<table.allAttributes:{ attr |
    +   /*<attr.ordinalPosition>*/"<attr.table.name.uppercased>. <attr.name.uppercased>}; separator=", \"\n"> "
    + "FROM <table.name.uppercased>, <table.allParentTables:{ table | <table.name.uppercased>}; separator=", "> "
    + "WHERE "
<table.primaryKey:{pk |
    +   "<attr.table.name.uppercased>.<pk.name.uppercased> = ? " /* :<pk.name> */ }; separator=" + \" AND \"\n">"
    <find_by_pk_sql_join(table=table, parent=table.parentTable)>
    <table.allParentTables:{ table | <if(table.parentTable)><find_by_pk_sql_join(table=table, parent=table.parentTable)><endif>}>;
<else>
<table.attributes:{attr |
    +  " <attr.name.uppercased>}; separator=", \"\n"> "
    + "FROM <table.name.uppercased> "
    + "WHERE "
    <table.primaryKey:{attr |+   " <attr.name.uppercased> = ? " /* :<attr.name> */ }; separator=" + \" AND \"\n">;
<endif>
>>

insert_sql(table, parent, repository, C) ::= <<
<!
 Generates the insert SQL.
 @param table the table.
 @param parent the parent.
 @param repository the repository.
 @param C the context.
 !>
/**
 * The SQL to insert.
 */
public static final String _INSERT_SQL =
      "INSERT "
    + "INTO <table.name.uppercased> "
    + "( "
<if(table.attributes.minus.readOnlyAttributes)>
<table.attributes.minus.readOnlyAttributes:{attr|
    +   "<attr.name.uppercased>}; separator=", \"\n"> "
<else>
<table.attributes:{attr|
    +   "<attr.name.uppercased>}; separator=", \"\n"> "
<endif>
    + ") "
    + "VALUES "
    + "( "
<if(table.attributes.minus.readOnlyAttributes)>
<table.attributes.minus.readOnlyAttributes:{attr|
    +   "?" /* :<attr.name> */}; separator=" + \", \"\n">
<else>
<table.attributes:{attr|
    +   "?" /* :<attr.name> */}; separator=" + \", \"\n">
<endif>
    + ")";
>>

update_sql(table, parent, repository, C) ::= <<
<!
 Generates the update SQL.
 @param table the table.
 @param parent the parent.
 @param repository the repository.
 @param C the context.
 !>

/**
 * The SQL to update.
 */
public static final String _UPDATE_SQL =
       "UPDATE <table.name.uppercased> "
    +  "SET "
<if(table.own.minus.primaryKey.minus.readOnlyAttributes)>
<table.own.minus.primaryKey.minus.readOnlyAttributes:{attr|
    + "<attr.name.uppercased> = ?" /* :<attr.name> */ }; separator=" + \", \"\n">
<else>
<table.primaryKey:{attr|
    + "<attr.name.uppercased> = ?" /* :<attr.name> */ }; separator=" + \", \"\n">
<endif>
    + " WHERE "
<if(table.primaryKey)>
<table.primaryKey:{attr |
    + "<attr.name.uppercased> = ?" /* :<attr.name> */ }; separator=" + \" AND \"\n">;
<else>
<table.attributes:{attr |
    + "<attr.name.uppercased> = ?" /* :<attr.name> */ }; separator=" + \" AND \"\n">;
<endif>
>>

delete_sql(table, parent, repository, C) ::= <<
<!
 Generates the delete SQL.
 @param table the table.
 @param parent the parent.
 @param repository the repository.
 @param C the context.
 !>

/**
 * The SQL to delete.
 */
public static final String _DELETE_SQL =
      "DELETE "
    + "FROM <table.name.uppercased> "
    + "WHERE "
<if(table.primaryKey)>
<table.primaryKey:{attr |
    + "<attr.name.uppercased> = ?" /* :<attr.name> */ }; separator=" + \" AND \"\n">;
<else>
<table.attributes:{attr |
    + "<attr.name.uppercased> = ?" /* :<attr.name> */ }; separator=" + \" AND \"\n">;
<endif>
>>

custom_selects_sql(table, repository, C) ::= <<
<table.customSelects:{sql|
<if(!sql.dynamic)>
<if(sql.value.splitAndSurroundByDoubleQuotes)>

/**
 * The <sql.id> SQL.
 */
public static final String <sql.id.normalized.uppercased>_SQL =
    <sql.value.splitAndSurroundByDoubleQuotes; separator=" +\n">;
<endif>
<endif>
}; separator="\n">
>>

custom_selects_for_update_sql(table, repository, C) ::= <<
// custom selects-for-update
<table.customSelectsForUpdate:{sql|
<if(!sql.dynamic)>

/**
 * The <sql.id> SQL.
 */
public static final String <sql.id.normalized.uppercased>_SQL =
    <sql.value.splitAndSurroundByDoubleQuotes; separator=" +\n"><endif>;}; separator="\n">
>>

custom_updates_or_inserts_sql(table, repository, C) ::= <<
// custom updates or inserts
<table.customUpdatesOrInserts:{sql|
<if(!sql.dynamic)>
<if(sql.value.splitAndSurroundByDoubleQuotes)>

/**
 * The <sql.id> SQL.
 */
public static final String <sql.id.normalized.uppercased>_SQL =
    <sql.value.splitAndSurroundByDoubleQuotes; separator=" +\n">;
<endif>
<endif>
}; separator="\n">
>>

constructor(table, repository, engine, C) ::= <<
<!
 Creates the constructor.
 @param table the table.
 @param repository the repository.
 @param C the context.
 !>
/**
 * Builds a {@link <engine.name><table.name.voName>DAO} instance
 * with given data source.
 * @param dataSource the required {@link javax.sql.DataSource data source}.
 * @param daoListener the {@link DAOListener}
 * instance.
 */
protected <engine.name><table.name.voName>DAO(
    <notnull(C=C)>final DataSource dataSource, <nullable(C=C)>final DAOListener daoListener)
{
    super(dataSource, daoListener);
}
>>

find_by_primary_key(table, parent, repository, C) ::= <<
<!
 Generates the find-by-primary-key methods.
 @param table the table.
 @param parent the parent.
 @param repository the repository.
 @param C the context.
!>

/**
<if(table.voDecorated)>
 * Retrieves {@link <table.name.voName>Decorator} (table <table.name>) information
<else>
 * Retrieves {@link <table.name.voName>} information
<endif>
 * filtering by its primary key.
 <table.primaryKey:{ attr | <attribute_javadoc(attr=attr)>}; separator="\n">
<if(table.voDecorated)>
 * @return the {@link <table.name.voName>Decorator} (table <table.name>) matching given
<else>
 * @return the {@link <table.name.voName>} matching given
<endif>
 * primary key.
 */
@Override
<nullable(C=C)>
<if(table.voDecorated)
 >public <table.name.voName>Decorator findByPrimaryKey(<
else
 >public <table.name.voName> findByPrimaryKey(<
endif>
    <table.primaryKey:{ attr | <attribute_method_parameter_declaration(attribute=attr, usePrefix=false, prefix="", C=C)>}; separator=", ">)
{
    return
        findByPrimaryKey(
            <table.primaryKey:{ attr | <attr.name.uncapitalized>}; separator=",\n">,
            auditSql(_FIND_BY_PK_SQL),
            createTransactionTemplate(getDataSource()),
            getDAOListener());
}

/**
<if(table.voDecorated)>
 * Retrieves {@link <table.name.voName>Decorator} (table <table.name>) information
<else>
 * Retrieves {@link <table.name.voName>} information
<endif>
 * filtering by its primary key.
 <table.primaryKey:{ attr | <attribute_javadoc(attr=attr)>}; separator="\n">
 * @param query the query to find by primary key.
 * @param transactionTemplate the {@link TransactionTemplate}
 * instance.
 * @param daoListener the {@link DAOListener} instance.
<if(table.voDecorated)>
 * @return the {@link <table.name.voName>Decorator} (table <table.name>) matching given
<else>
 * @return the {@link <table.name.voName>} matching given
<endif>
 * primary key.
 */
@SuppressWarnings("unchecked")
<nullable(C=C)>
<if(table.voDecorated)>
protected <table.name.voName>Decorator findByPrimaryKey(
<else>
protected <table.name.voName> findByPrimaryKey(
<endif>
    <table.primaryKey:{ attr | <attribute_method_parameter_declaration(attribute=attr, usePrefix=false, prefix="", C=C)>}; separator=",\n">,
    <notnull(C=C)>final String query,
    <notnull(C=C)>final TransactionTemplate transactionTemplate,
    <nullable(C=C)>final DAOListener daoListener)
{
    return
<if(table.voDecorated)>
            transactionTemplate.execute(
                new V24QueryTransactionCallback\<<engine.name><table.name.voName>DAO, <table.name.voName>Decorator>(
<else>
            transactionTemplate.execute(
                new V24QueryTransactionCallback\<<engine.name><table.name.voName>DAO, <table.name.voName>\>(
<endif>
                    new V24PreparedStatementCreator(query, daoListener),
                    new <table.name.voName>PkStatementSetter(
                        <table.primaryKey:{ attr | <attr.name.uncapitalized>}; separator=",\n">),
                    new <table.name.voName>ResultSetSingleExtractor(query, daoListener),
                    this));
}
>>

insert(table, parent, repository, C) ::= <<
<!
 Generates the JDBC insert logic.
 @param table the table.
 @param parent the parent.
 @param repository the repository.
 @param C the context.
 !>
/**
 * Persists {@link <table.name.voName>} information.
<if(parent)>
 <table.all.minus.readOnly.minus.externallyManagedAttributes:{ attr | <attribute_javadoc(attr=attr)>}; separator="\n">
<else>
 <table.own.minus.readOnly.minus.externallyManagedAttributes:{ attr | <attribute_javadoc(attr=attr)>}; separator="\n">
<endif>
 */
@Override
public void insert(
<if(parent)>
    <table.all.minus.readOnly.minus.externallyManagedAttributes:{ attr | <attribute_method_parameter_declaration(attribute=attr, usePrefix=false, prefix="", C=C)>}; separator=",\n">)
<else>
    <table.own.minus.readOnly.minus.externallyManagedAttributes:{ attr | <attribute_method_parameter_declaration(attribute=attr, usePrefix=false, prefix="", C=C)>}; separator=",\n">)
<endif>
{
    create(
<if(parent)>
        <table.all.minus.readOnly.minus.externallyManagedAttributes:{ attr | <attr.name.uncapitalized>}; separator=",\n">,
<else>
        <table.own.minus.readOnly.minus.externallyManagedAttributes:{ attr | <attr.name.uncapitalized>}; separator=",\n">,
<endif>
        false);
}
>>

create(table, parent, repository, C) ::= <<
<!
 Generates the JDBC create logic.
 @param table the table.
 @param parent the parent.
 @param repository the repository.
 @param C the context.
 !>
/**
 * Inserts and retrieves the newly-inserted
<if(table.voDecorated)>
 * {@link <table.name.voName>Decorator} (table <table.name>) instance.
<else>
 * {@link <table.name.voName>} instance.
<endif>
<if(parent)>
 <table.all.minus.readOnly.minus.externallyManagedAttributes:{ attr | <attribute_javadoc(attr=attr)>}; separator="\n">
<else>
 <table.own.minus.readOnly.minus.externallyManagedAttributes:{ attr | <attribute_javadoc(attr=attr)>}; separator="\n">
<endif>
 */
@Override
<notnull(C=C)>
<if(table.voDecorated)>
public <table.name.voName>Decorator create(
<else>
public <table.name.voName> create(
<endif>
<if(parent)>
    <table.all.minus.readOnly.minus.externallyManagedAttributes:{ attr | <attribute_method_parameter_declaration(attribute=attr, usePrefix=false, prefix="", C=C)>}; separator=",\n">)
<else>
    <table.own.minus.readOnly.minus.externallyManagedAttributes:{ attr | <attribute_method_parameter_declaration(attribute=attr, usePrefix=false, prefix="", C=C)>}; separator=",\n">)
<endif>
{
    return
        create(
<if(parent)>
            <table.all.minus.readOnly.minus.externallyManagedAttributes:{ attr | <attr.name.uncapitalized>}; separator=",\n">,
<else>
            <table.own.minus.readOnly.minus.externallyManagedAttributes:{ attr | <attr.name.uncapitalized>}; separator=",\n">,
<endif>
            true);
}
<create2(table=table, parent=parent, repository=repository, C=C)>

<create3(table=table, parent=parent, repository=repository, C=C)>

>>

create2(table, parent, repository, C) ::= <<
<!
 Generates the JDBC create logic.
 @param table the table.
 @param parent the parent.
 @param repository the repository.
 @param C the context.
 !>

/**
 * Inserts and (optionally) retrieves the newly-inserted
<if(table.voDecorated)>
 * {@link <table.name.voName>Decorator} (table <table.name>) instance.
<else>
 * {@link <table.name.voName>} instance.
<endif>
<if(parent)>
 <table.all.minus.readOnly.minus.externallyManagedAttributes:{ attr | <attribute_javadoc(attr=attr)>}; separator="\n">
<else>
 <table.own.minus.readOnly.minus.externallyManagedAttributes:{ attr | <attribute_javadoc(attr=attr)>}; separator="\n">
<endif>
 * @param retrieveAfterwards whether to retrieve the new instance afterwards or not.
 */
<notnull(C=C)>
<if(table.voDecorated)>
protected <table.name.voName>Decorator create(
<else>
protected <table.name.voName> create(
<endif>
<if(parent)>
    <table.all.minus.readOnly.minus.externallyManagedAttributes:{ attr | <attribute_method_parameter_declaration(attribute=attr, usePrefix=false, prefix="", C=C)>}; separator=",\n">,
<else>
    <table.own.minus.readOnly.minus.externallyManagedAttributes:{ attr | <attribute_method_parameter_declaration(attribute=attr, usePrefix=false, prefix="", C=C)>}; separator=",\n">,
<endif>
    final boolean retrieveAfterwards)
{
    return
        create(
<if(parent)>
            <table.all.minus.readOnly.minus.externallyManagedAttributes:{ attr | <attr.name.uncapitalized>}; separator=",\n">,
<else>
            <table.own.minus.readOnly.minus.externallyManagedAttributes:{ attr | <attr.name.uncapitalized>}; separator=",\n">,
<endif>
            retrieveAfterwards,
            _INSERT_SQL,
            createTransactionTemplate(getDataSource()),
            <table.name.voName>Factory.getInstance(),
<if(parent)>
            <repository.capitalized>DataAccessManager.getInstance().get<parent.name.voName>DAO(),,
<endif>
            getDAOListener());
}
>>

create3(table, parent, repository, C) ::= <<
<!
 Generates the JDBC create logic, overloaded 4.
 @param table the table.
 @param parent the parent.
 @param repository the repository.
 @param C the context.
 !>
/**
 * Inserts and retrieves the newly-inserted
<if(table.voDecorated)>
 * {@link <table.name.voName>Decorator} (table <table.name>) instance.
<else>
 * {@link <table.name.voName>} instance.
<endif>
<if(parent)>
 <table.all.minus.readOnly.minus.externallyManagedAttributes:{ attr | <attribute_javadoc(attr=attr)>}; separator="\n">
<else>
 <table.own.minus.readOnly.minus.externallyManagedAttributes:{ attr | <attribute_javadoc(attr=attr)>}; separator="\n">
<endif>
 * @param retrieveAfterwards whether to retrieve the new instance afterwards or not.
 * @param query the query required to insert given information.
 * @param transactionTemplate the {@link TransactionTemplate}
 * instance.
 * @param factory the {@link <table.name.voName>Factory}
 * instance.
<if(parent)>
 * @param <parent.name.lowercased>DAO the {@link <parent.name.voName>DAO} instance.
<endif>
 * @param daoListener the {@link DAOListener} instance.
 */
@SuppressWarnings("unchecked")
<notnull(C=C)>
<if(table.voDecorated)>
protected <table.name.voName>Decorator create(
<else>
protected <table.name.voName> create(
<endif>
<if(parent)>
    <table.all.minus.readOnly.minus.externallyManagedAttributes:{ attr | <attribute_method_parameter_declaration(attribute=attr, usePrefix=false, prefix="", C=C)>}; separator=",\n">,
<else>
    <table.own.minus.readOnly.minus.externallyManagedAttributes:{ attr | <attribute_method_parameter_declaration(attribute=attr, usePrefix=false, prefix="", C=C)>}; separator=",\n">,
<endif>
    final boolean retrieveAfterwards,
    <notnull(C=C)>final String query,
    <notnull(C=C)>final TransactionTemplate transactionTemplate,
    <notnull(C=C)>final <table.name.voName>Factory factory,
<if(parent)>
    <notnull(C=C)>final <parent.name.voName>DAO <parent.name.lowercased>DAO,
<endif>
    <nullable(C=C)>final DAOListener daoListener)
{
<if(table.voDecorated)>
    <notnull(C=C)>final <table.name.voName>Decorator result;
<else>
    <notnull(C=C)>final <table.name.voName> result;
<endif>

<if(parent)>

    <parent.name.voName> <parent.name.lowercased> =
        <parent.name.lowercased>DAO.create(
            <parent.all.minus.readOnly.minus.externallyManagedAttributes:{ attr | <attr.name.uncapitalized>}; separator=",\n">);

<table.primaryKey:{attr |
    <attr.fieldType> <attr.name.uncapitalized> = <parent.name.lowercased>.get<attr.name.capitalized>();}; separator="\n">

<if(table.all.minus.readOnly.minus.externallyManagedAttributes)>
    <table.all.externallyManaged.minus.readOnlyAttributes:{ attr | <em_attribute_value_retrieval(attr=attr, table=table, C=C)>}; separator="\n">

<endif>
<else>
<if(table.externallyManaged.minus.readOnlyAttributes)>

    <table.externallyManaged.minus.readOnlyAttributes:{ attr | <em_attribute_value_retrieval(attr=attr, table=table, C=C)>}; separator="\n">
<endif>
<endif>

    transactionTemplate.execute(
        new V24UpdateTransactionCallback\<<engine.name><table.name.voName>DAO>(
            new V24PreparedStatementCreator(query, daoListener),
            new <table.name.voName>StatementSetter(
                new <table.name.voName>Impl(
<if(parent)>
                    <table.all.minus.readOnlyAttributes:{ attr | <attr.name.uncapitalized>}; separator=",\n">),
<else>
                    <table.own.minus.readOnlyAttributes:{ attr | <attr.name.uncapitalized>}; separator=",\n">),
<endif>
                V24PreparedStatementSetter.Operation.INSERT),
            this));

    if (retrieveAfterwards)
    {
<if(table.readOnlyAttributes)>
        result = findByPrimaryKey(<table.primaryKey:{ attr |<attr.name.uncapitalized>}; separator=", ">);

        if (result == null)
        {
            throw
                new RuntimeException(
                      "Just inserted a new <table.name.voName> ("
                    + "<table.primaryKey:{ attr |<attr.name> -> " + <attr.name.uncapitalized>}; separator="\n                    + \", ">
                    + "), but it's not retrievable afterwards");
        }
<else>
        result =
            factory.create<table.name.voName>(
                <table.attributes:{ attr |<attr.name.uncapitalized>}; separator=",\n">);
<endif>
    }
    else
    {
        result = null;
    }

    return result;
}
>>

update(table, parent, repository, C) ::= <<
<!
  Creates the update method.
  @param table the table.
  @param parent the parent.
  @param repository the repository.
  @param C the context.
 !>
/**
 * Updates {@link <table.name.voName>} information.
<if(parent)>
 <table.all.minus.readOnlyAttributes:{ attr | <attribute_javadoc(attr=attr)>}; separator="\n">
<else>
 <table.own.minus.ReadOnlyAttributes:{ attr | <attribute_javadoc(attr=attr)>}; separator="\n">
<endif>
 * @return the number of entities updated.
 */
@Override
public int update(
<if(parent)>
    <table.all.minus.readOnlyAttributes:{ attr | <attribute_declaration_impl(attr=attr, C=C)>}; separator=",\n">)
<else>
    <table.own.minus.readOnlyAttributes:{ attr | <attribute_declaration_impl(attr=attr, C=C)>}; separator=",\n">)
<endif>
{
    return
        update(
<if(parent)>
            <table.all.minus.readOnlyAttributes:{ attr | <attr.name.uncapitalized>}; separator=",\n">,
            auditSql(_UPDATE_SQL),
            getDataSource(),
            <repository.capitalized>DataAccessManager.getInstance());
<else>
            <table.own.minus.readOnlyAttributes:{ attr | <attr.name.uncapitalized>}; separator=",\n">,
            auditSql(_UPDATE_SQL),
            getDataSource());
<endif>
}

<update2(table=table, parent=parent, repository=repository, C=C)>

<update3(table=table, parent=parent, repository=repository, C=C)>

<update4(table=table, parent=parent, repository=repository, C=C)>
>>

update2(table, parent, repository, C) ::= <<
/**
 * Updates {@link <table.name.voName>} information.
<if(parent)>
 <table.all.minus.readOnlyAttributes:{ attr | <attribute_javadoc(attr=attr)>}; separator="\n">
<else>
 <table.own.minus.readOnlyAttributes:{ attr | <attribute_javadoc(attr=attr)>}; separator="\n">
<endif>
 * @param query the query used to perform the update operation.
 * @param dataSource the {@link DataSource} instance.
<if(parent)>
 * @param dataAccessManager the {@link <repository.capitalized>DataAccessManager} instance.
<endif>
 * @return the number of entities updated.
 */
protected int update(
<if(parent)>
    <table.all.minus.readOnlyAttributes:{ attr | <attribute_declaration_impl(attr=attr, C=C)>}; separator=",\n">,
    <notnull(C=C)>final String query,
    <notnull(C=C)>final DataSource dataSource,
    <notnull(C=C)>final <repository.capitalized>DataAccessManager dataAccessManager)
<else>
    <table.own.minus.readOnlyAttributes:{ attr | <attribute_declaration_impl(attr=attr, C=C)>}; separator=",\n">,
    <notnull(C=C)>final String query,
    <notnull(C=C)>final DataSource dataSource)
<endif>
{
    return
        update(
<if(parent)>
            <table.all.minus.readOnlyAttributes:{ attr | <attr.name.uncapitalized>}; separator=",\n">,
            query,
            new DataSourceTransactionManager(dataSource),
            dataAccessManager.get<parent.name.voName>DAO());
<else>
            <table.own.minus.readOnlyAttributes:{ attr | <attr.name.uncapitalized>}; separator=",\n">,
            query,
            new DataSourceTransactionManager(dataSource));
<endif>
}
>>

update3(table, parent, repository, C) ::= <<
/**
 * Updates {@link <table.name.voName>} information.
<if(parent)>
 <table.all.minus.readOnlyAttributes:{ attr | <attribute_javadoc(attr=attr)>}; separator="\n">
<else>
 <table.own.minus.readOnlyAttributes:{ attr | <attribute_javadoc(attr=attr)>}; separator="\n">
<endif>
 * @param query the query used to perform the update operation.
 * @param transactionManager the {@link PlatformTransactionManager}
 * instance.
<if(parent)>
 * @param parentDAO the {@link <parent.name.voName>DAO} instance.
<endif>
 * @return the number of entities updated.
 */
protected int update(
<if(parent)>
    <table.all.minus.readOnlyAttributes:{ attr | <attribute_declaration_impl(attr=attr, C=C)>}; separator=",\n">,
    <notnull(C=C)>final String query,
    <notnull(C=C)>final PlatformTransactionManager transactionManager,
    <notnull(C=C)>final <parent.name.voName>DAO parentDAO)
<else>
    <table.own.minus.readOnlyAttributes:{ attr | <attribute_declaration_impl(attr=attr, C=C)>}; separator=",\n">,
    <notnull(C=C)>final String query,
    <notnull(C=C)>final PlatformTransactionManager transactionManager)
<endif>
{
    return
        update(
<if(parent)>
            <table.own.minus.readOnlyAttributes:{ attr | <attr.name.uncapitalized>}; separator=",\n">,
<else>
            <table.all.minus.readOnlyAttributes:{ attr | <attr.name.uncapitalized>}; separator=",\n">,
<endif>
            query,
            new TransactionTemplate(transactionManager),
<if(parent)>
            parentDAO,
<endif>
            getDAOListener());
}
>>

update4(table, parent, repository, C) ::= <<
/**
 * Updates {@link <table.name.voName>} information.
<if(parent)>
 <table.all.minus.readOnlyAttributes:{ attr | <attribute_javadoc(attr=attr)>}; separator="\n">
<else>
 <table.own.minus.readOnlyAttributes:{ attr | <attribute_javadoc(attr=attr)>}; separator="\n">
<endif>
 * @param query the query used to perform the update operation.
 * @param transactionTemplate the {@link TransactionTemplate} instance.
<if(parent)>
 * @param parentDAO the {@link <parent.name.voName>DAO} instance.
<endif>
 * @param daoListener the {@link DAOListener} instance.
 * @return the number of entities updated.
 */
protected int update(
<if(parent)>
    <table.all.minus.readOnlyAttributes:{ attr | <attribute_declaration_impl(attr=attr, C=C)>}; separator=",\n">,
<else>
    <table.own.minus.readOnlyAttributes:{ attr | <attribute_declaration_impl(attr=attr, C=C)>}; separator=",\n">,
<endif>
    <notnull(C=C)>final String query,
    <notnull(C=C)>final TransactionTemplate transactionTemplate,
<if(parent)>
    <notnull(C=C)>final <parent.name.voName>DAO parentDAO,
<endif>
    <nullable(C=C)>final DAOListener daoListener)
{
    int result = -10;

<if(parent)>
    parentDAO.update(
        <parent.all.minus.readOnly.minus.externallyManagedAttributes:{ attr | <attr.name.uncapitalized>}; separator=",\n">);
<endif>
    <nullable(C=C)>final Integer t_Result =
        transactionTemplate.execute(
            new V24UpdateTransactionCallback\<<engine.name><table.name.voName>DAO>(
                new V24PreparedStatementCreator(query, daoListener),
                new <table.name.voName>StatementSetter(
                    new <table.name.voName>Impl(
<if(parent)>
                        <table.all.minus.readOnlyAttributes:{ attr | <attr.name.uncapitalized>}; separator=",\n">),
<else>
                        <table.own.minus.readOnlyAttributes:{ attr | <attr.name.uncapitalized>}; separator=",\n">),
<endif>
<if(C.lob_handling_required)>
                    true,
                    false,
                    false),
<else>
                    V24PreparedStatementSetter.Operation.UPDATE),
<endif>
                this));

    if  (t_Result != null)
    {
        result = t_Result.intValue();
    }

    return result;
}
>>

delete(table, parent, repository, C) ::= <<
<!
  Creates the delete methods.
  @param table the table.
  @param parent the parent.
  @param repository the repository.
  @param C the context.
 !>
/**
 * Deletes {@link <table.name.voName>} information.
 <table.primaryKey:{ attr | <attribute_javadoc(attr=attr)>}; separator="\n">
 */
@Override
public void delete(
    <table.primaryKey:{ attr | <attribute_method_parameter_declaration(attribute=attr, usePrefix=false, prefix="", C=C)>}; separator=",\n">)
{
<if(table.foreignKeys)>
    <table.foreignKeys:{ fk | <fk_dao_delete_call(foreignKey=fk, table=table)> };
        separator="\n\n">

<endif>
    deleteNoFk(<table.primaryKey:{ attr | <attr.name.uncapitalized>}; separator=", ">);
}

<delete2(table=table, parent=parent, repository=repository, C=C)>

<delete3(table=table, parent=parent, repository=repository, C=C)>

<delete4(table=table, parent=parent, repository=repository, C=C)>

<delete5(table=table, parent=parent, repository=repository, C=C)>
>>

delete2(table, parent, repository, C) ::= <<
<!
  Creates a delete method, overridden 2.
  @param table the table.
  @param parent the parent.
  @param repository the repository.
  @param C the context.
 !>
/**
 * Deletes {@link <table.name.voName>} information.
 <table.primaryKey:{ attr | <attribute_javadoc(attr=attr)>}; separator="\n">
 */
protected void deleteNoFk(
    <table.primaryKey:{ attr | <attribute_method_parameter_declaration(attribute=attr, usePrefix=false, prefix="", C=C)>}; separator=",\n">)
{
    deleteNoFk(
        <table.primaryKey:{ attr | <attr.name.uncapitalized>}; separator=",\n">,
        auditSql(_DELETE_SQL),
<if(parent)>
        getDataSource(),
        <repository.capitalized>DataAccessManager.getInstance());
<else>
        getDataSource());
<endif>
}
>>

delete3(table, parent, repository, C) ::= <<
<!
  Creates a delete method, overridden 3.
  @param table the table.
  @param parent the parent.
  @param repository the repository.
  @param C the context.
 !>
/**
 * Deletes {@link <table.name.voName>} information without considering foreign keys
 * pointing to the row to delete.
 <table.primaryKey:{ attr | <attribute_javadoc(attr=attr)>}; separator="\n">
 * @param query the query used to perform the delete operation.
 * @param dataSource the {@link DataSource} instance.
<if(parent)>
 * @param dataAccessManager the {@link <repository.capitalized>DataAccessManager} instance.
<endif>
 */
protected void deleteNoFk(
    <table.primaryKey:{ attr | <attribute_method_parameter_declaration(attribute=attr, usePrefix=false, prefix="", C=C)>}; separator=",\n">,
    <notnull(C=C)>final String query,
<if(parent)>
    <notnull(C=C)>final DataSource dataSource,
    <notnull(C=C)>final <repository.capitalized>DataAccessManager dataAccessManager)
<else>
    <notnull(C=C)>final DataSource dataSource)
<endif>
{
    deleteNoFk(
        <table.primaryKey:{ attr | <attr.name.uncapitalized>}; separator=",\n">,
        query,
<if(parent)>
        new DataSourceTransactionManager(dataSource),
        dataAccessManager.get<parent.name.voName>DAO());
<else>
        new DataSourceTransactionManager(dataSource));
<endif>
}
>>

delete4(table, parent, repository, C) ::= <<
<!
  Creates a delete method, overridden 3.
  @param table the table.
  @param parent the parent.
  @param repository the repository.
  @param C the context.
 !>
/**
 * Deletes {@link <table.name.voName>} information without considering foreign keys
 * pointing to the row to delete.
 <table.primaryKey:{ attr | <attribute_javadoc(attr=attr)>}; separator="\n">
 * @param query the query used to perform the delete operation.
 * @param transactionManager the {@link PlatformTransactionManager} instance.
<if(parent)>
 * @param dataAccessManager the {@link <repository.capitalized>DataAccessManager} instance.
<endif>
 */
protected void deleteNoFk(
    <table.primaryKey:{ attr | <attribute_method_parameter_declaration(attribute=attr, usePrefix=false, prefix="", C=C)>}; separator=",\n">,
    <notnull(C=C)>final String query,
<if(parent)>
    <notnull(C=C)>final PlatformTransactionManager transactionManager,
    <notnull(C=C)>final <repository.capitalized>DataAccessManager dataAccessManager)
<else>
    <notnull(C=C)>final PlatformTransactionManager transactionManager)
<endif>
{
    deleteNoFk(
        <table.primaryKey:{ attr | <attr.name.uncapitalized>}; separator=",\n">,
        query,
<if(parent)>
        new TransactionTemplate(transactionManager),
        dataAccessManager.get<parent.name.voName>DAO(),
<else>
        new TransactionTemplate(transactionManager),
<endif>
        getDAOListener());
}
>>

delete5(table, parent, repository, C) ::= <<
<!
  Creates a delete method, overridden 4.
  @param table the table.
  @param parent the parent.
  @param repository the repository.
  @param C the context.
 !>
/**
 * Deletes {@link <table.name.voName>} information without considering foreign keys
 * pointing to the row to delete.
 <table.primaryKey:{ attr | <attribute_javadoc(attr=attr)>}; separator="\n">
 * @param query the query used to perform the delete operation.
 * @param transactionTemplate the {@link TransactionTemplate}
 * instance.
<if(parent)>
 * @param parentDAO the {@link <parent.name.voName>DAO} instance.
<endif>
 * @param daoListener the {@link DAOListener} instance.
 */
protected void deleteNoFk(
    <table.primaryKey:{ attr | <attribute_method_parameter_declaration(attribute=attr, usePrefix=false, prefix="", C=C)>}; separator=",\n">,
    <notnull(C=C)>final String query,
    <notnull(C=C)>final TransactionTemplate transactionTemplate,
<if(parent)>
    <notnull(C=C)>final <parent.name.voName>DAO parentDAO,
<endif>
    <nullable(C=C)>final DAOListener daoListener)
{
    transactionTemplate.execute(
        new V24UpdateTransactionCallback\<<engine.name><table.name.voName>DAO>(
            new V24PreparedStatementCreator(query, daoListener),
            new <table.name.voName>PkStatementSetter(
                <table.primaryKey:{ attr | <attr.name.uncapitalized>}; separator=",\n">),
            this));
<if(parent)>
    parentDAO.delete(
        <table.primaryKey:{ attr | <attr.name.uncapitalized>}; separator=",\n">);
<endif>
}
>>

extractors(table, parent, repository, C) ::= <<
<!
  Creates the extractor classes.
  @param table the table.
  @param parent the parent.
  @param repository the repository.
  @param C the context.
 !>
/**
 * Extracts \<i><table.name.voName>\</i> value objects from result sets.
 <class_common_javadoc(template="org/acmsl/queryj/templates/dao/DAO.stg", C=C)>
 */
@SuppressWarnings("unused")
public static class <table.name.voName>PkResultSetExtractor
    extends V24ResultSetSingleExtractor\<Map\<String, ?\>>
{
    /**
    * Constructs a new {@link <table.name.voName>PkResultSetExtractor}.
    * @param sql the original sql used.
    * @param daoListener the dao listener.
    */
    public <table.name.voName>PkResultSetExtractor(
        <notnull(C=C)>final String sql, <nullable(C=C)>final DAOListener daoListener)
    {
        super(sql, daoListener);
    }

    /**
     * Extracts \<i><table.name.voName>\</i> information from given result set.
     * @param resultSet the result set.
     * @return the primary key or {@code null} if the operation returned no data.
     */
    @Override
    @SuppressWarnings("unchecked")
    <notnull(C=C)>
    protected Map\<String, ?> extractValue(<notnull(C=C)>final ResultSet resultSet)
    throws  SQLException,
            DataAccessException
    {
        <notnull(C=C)>final Map\<String, ?> result = new HashMap\<String, Object>();

        int index = 0;

        <table.primaryKey:{ attr | <resultset_extractor_parameter_retrieval(
              name=attr.name.lowercased,
              getterMethod=attr.getterMethod,
              objectType=attr.objectType,
              isPrimitive=attr.primitive)> }; separator="\n">

        return result;
    }
}

/**
 * Executes the update method on JdbcTemplate class.
 * @param creator the {@link PreparedStatementCreator} instance.
 * @param setter the {@link PreparedStatementSetter} instance.
 */
@Override
public int update(
    <notnull(C=C)>final PreparedStatementCreator creator,
    <notnull(C=C)>final PreparedStatementSetter setter)
{
    return super.update(creator, setter);
}

/**
 * Executes the query method on JdbcTemplate class.
 * @param creator the {@link PreparedStatementCreator} instance.
 * @param setter the {@link PreparedStatementSetter} instance.
 * @param extractor the {@link ResultSetExtractor} instance.
 */
@Override
<notnull(C=C)>
public \<T> T query(
    <notnull(C=C)>final PreparedStatementCreator creator,
    <notnull(C=C)>final PreparedStatementSetter setter,
    <notnull(C=C)>final ResultSetExtractor\<T> extractor)
{
    return super.query(creator, setter, extractor);
}
>>

resultset_extractor_parameter_retrieval(name, getterMethod, objectType, isPrimitive) ::= <<
<!
  Generates the piece of code to build a concrete value-object attribute.
  @param name the attribute name.
  @param getterMethod the getter method associated to such attribute.
  @param objectType the attribute type (Java version).
  @param isPrimitive whether the attribute is modelled as an instance or as
  a primitive type.
!>
index = index + 1;//

((Map\<String, <objectType>\>) result).put("<name>", <if(isPrimitive)><objectType>.valueOf(<endif>resultSet.<getterMethod>(index)<if(isPrimitive)>)<endif>);
>>

find_constant_by_pk(primaryKey, table, C) ::= <<
/**
 * Loads \<i><table.name.voName>\</i> information from the constant pool,
 * filtering by the primary key.
 <primaryKey:{ attribute | <attribute_javadoc(attr=attribute)>}; separator="\n">
 * @return the {@link <table.name.voName>} instance.
 */
@Override
<nullable(C=C)>
public <table.name.voName> findConstantByPk(
    <primaryKey:{ attr | <attribute_method_parameter_declaration(attribute=attr, usePrefix=false, prefix="", C=C)>}; separator=",\n">)
{
    <nullable(C=C)><table.name.voName> result = null;

    boolean found;

    for (<nullable(C=C)>final <table.name.voName> item : FIXED_CONSTANTS)
    {
        if  (item != null)
        {
            found = true;

            <primaryKey:{ attr | <static_attribute_check(attr=attr)>}; separator="\n">
            if  (found)
            {
                result = item;
                break;
            }
        }
    }

    return result;
}
>>

find_constant_methods(attribute, table, C) ::= <<
<!
  Declares the methods to operate directly on defined constants.
  @param attribute the attribute.
  @param table the table.
!>
/**
 * Loads \<i><table.name>\</i> information from the pre-existing constants,
 * filtering by \<i><attribute.name>\</i>.
 <attribute_javadoc(attr=attribute)>
 * @return the {@link <table.name.voName>} instances matching the criteria.
 */
@Override
<notnull(C=C)>
public List\<<table.name.voName>\> findConstantsBy<attribute.name.capitalized>(<
    if(!attribute.primitive)><
      if(!attribute.primitiveWrapper)
       ><notnull(C=C)><
      else><
        if(attribute.nullable)
         ><notnull(C=C)><
        endif><
      endif><
    endif>final <attribute.primitiveType> <attribute.name.lowercased.uncapitalized>)
{
    <notnull(C=C)>final List\<<table.name.voName>\> result = new ArrayList\<<table.name.voName>\>(FIXED_CONSTANTS.size());

    for  (<nullable(C=C)>final <table.name.voName> item : FIXED_CONSTANTS)
    {
        if  (item != null)
        {
            <find_constant_check_attribute(attribute=attribute, C=C); separator="\n">
            {
                result.add(item);
            }
        }
    }

    return result;
}

/**
 * Loads \<i><table.name>\</i> information from the pre-existing constants,
 * filtering by \<i><attribute.name>\</i>.
 <attribute_javadoc(attr=attribute)>
 * @return the {@link <table.name.voName>} instance.
 */
@Override
<nullable(C=C)>
public <table.name.voName> findConstantBy<attribute.name.capitalized>(<
    if(!attribute.primitive)><
      if(!attribute.primitiveWrapper)
       ><notnull(C=C)><
      else><
        if(attribute.nullable)
         ><notnull(C=C)><
        endif><
      endif><
    endif>final <attribute.primitiveType> <attribute.name.lowercased.uncapitalized>)
{
    <nullable(C=C)>final <table.name.voName> result;

    <notnull(C=C)>final List\<<table.name.voName>\> constants = findConstantsBy<attribute.name.capitalized>(<attribute.name.lowercased.uncapitalized>);

    if (constants.size() > 0)
    {
        result = constants.get(0);
    }
    else
    {
        result = null;
    }

    return result;
}

>>

static_attribute_check(attr) ::= <<
<!
 Generates the code to perform the static check on given attribute.
 @param attr the attribute
!>
<if(attr.primitive)>
<static_primitive_attribute_check(attr=attr)>
<else>
<static_object_attribute_check(attr=attr)>
<endif>
>>

static_primitive_attribute_check(attr) ::= <<
<!
 Generates the code to perform the static check on given primitive attribute.
 @param attr the attribute
!>
found =
    (   (found)
     && (item.get<attr.name.capitalized>() == <attr.name.uncapitalized>));
>>

static_object_attribute_check(attr) ::= <<
<!
 Generates the code to perform the static check on given primitive attribute.
 @param attr the attribute
!>
if  (found)
{
    <nullable(C=C)>final Object t_<attr.name.capitalized> =
        t_CurrentItem.get<attr.name.capitalized>();

    if  (t_<attr.name.capitalized> == null)
    {
        found = (<attr.name> == null);
    }
    else
    {
        found = t_<attr.name.capitalized>.equals(<attr.name>);
    }
}
>>

em_attribute_value_retrieval(attr, table, C) ::= <<
<!
  Writes the sentence to retrieve an externally-managed value.
  @param attr the attribute.
  @param table the table.
!>
<notnull(C=C)>final String <attr.name.uncapitalized>Sql =
<if(attr.sequence)>
     "select <attr.sequence>.nextval <attr.name.lowercased> from dual";
<else>
<if(attr.query)>
     "<attr.query>";
<else>
     "select <attr.keyword> <attr.name.lowercased> from dual";
<endif>
<endif>


<notnull(C=C)>final Map\<String, <attr.objectType>\> <attr.name.uncapitalized>Map =
   transactionTemplate.execute(
       new V24QueryTransactionCallback\<<engine.name><table.name.voName>DAO, Map\<String, <attr.objectType>\>>(
           <attr.name.uncapitalized>Sql,
           new <attr.name.capitalized>ResultSetSingleExtractor(<attr.name.uncapitalized>Sql, daoListener),
           this));

final <attr.javaType> <attr.name.uncapitalized> = <attr.name.uncapitalized>Map.get("<attr.name.lowercased>");
>>

fk_dao_delete_call(foreignKey, table) ::= <<
<!
  Writes the code needed to use the DAO associated to a
  concrete foreign key to perform a delete operation.
  @param foreignKey the foreign key.
!>
<if(foreignKey.nullable)>
//<foreignKey.targetTableName.voName>DAO.discardRelationTo<foreignKey.source.name.voName>(
<else>
//<foreignKey.targetTableName.voName>DAO.deleteBy<foreignKey.source.name.voName>(
<endif>
    <foreignKey.attributes:{ attr | //<attr.name.uncapitalized>}; separator=",\n">);
>>

fk_delete_query(foreignKey) ::= <<
<!
 Defines the SQL to delete referred entities.
 @param foreignKey the foreign key.
!>
/**
 * The SQL to delete <foreignKey.fkName>-associated entities.
 */
public static final String _DELETE_BY_<foreignKey.name.uppercased>_SQL =
      "DELETE "
    + "FROM <table.name.uppercased> "
    + "WHERE "
<foreignKey:{attr|
    +   "<attr.name.uppercased> = ?}; separator=" AND \"\n">";

>>

fk_delete_method(foreignKey, table) ::= <<
<!
  Writes the deleteByXX method for a concrete foreign key.
  @param table the table.
  @param foreignKey the foreign key.
!>
/**
 * Deletes <table.name> information from the persistence layer filtering
 * by given foreign keys.
 * \<br/>\<b>This method is not implemented yet\</b>.
 <foreignKey.attributes:{ attr | <attribute_javadoc(attr=attr)>}; separator="\n">
 */
@Override
public void deleteBy<foreignKey.attributes:{attr |<attr.name.capitalized>}>(
    <foreignKey.attributes:{ attr | <attribute_method_parameter_declaration(attribute=attr, usePrefix=false, prefix="", C=C)>}; separator=",\n">)
{
    // TODO: not refactored yet. Removed till then.
    throw new IllegalArgumentException("Not implemented yet");
}
>>

insert_attribute(attr) ::= <<
<!
 Generates the insert part corresponding to given attribute.
 @param attr the attribute.
!>
<if(attr.clob)>
"EMPTY_CLOB()
<else>
"?
<endif>
>>

delete_by_fk_sql(foreignKey) ::= <<
<!
 Generates the constant with the SQL to delete by given fk.
 @param foreignKey the foreign key.
!>
 /**
  * The SQL to delete by <foreignKey.attributes:{attr |<attr.name>}; separator=".">.
  */
public static final String DELETE_BY_<foreignKey.attributes:{attr |<attr.name.uppercased>}; separator="_">_SQL =
    "DELETE FROM <table.name.uppercased> "
    + "WHERE "
<foreignKey.attributes:{attr|
    + " <attr.name.uppercased> = ? " /* :<attr.name> */}; separator="\n    + \" AND \"">;
>>

find_by_pk_sql_join(table, parent) ::= <<
<!
 Generates the part of the where clause in find-by-pk-sql.
 @param table the ForeignKey of the child, pointing to its parent.
 @param parentPrimaryKey the parent's primary key.
!>
<find_by_pk_sql_join_fk(parentForeignKey=table.parentForeignKey, parentPrimaryKey=parent.primaryKey)>
>>

find_by_pk_sql_join_fk(parentForeignKey, parentPrimaryKey) ::= <<
<!
 Generates the part of the where clause in find-by-pk-sql.
 @param parentForeignKey the ForeignKey of the child, pointing to its parent.
 @param parentPrimaryKey the parent's primary key.
!>
<parentForeignKey.attributes,parentPrimaryKey:{ pk, parentPk |
+   " AND <pk.table.name.uppercased>.<pk.name.uppercased> = <parentPk.table.name.uppercased>.<parentPk.name.uppercased> "}; separator="\n">
>>

attribute_resultset_extractor_class(table, repository, attr, C) ::= <<
<!
 Generates an inner resultset-extractor class for given attribute.
 @param table the table.
 @param repository the table repository name.
 @param attr the attribute.
 @param context the context.
!>
/**
 * Extracts \<i><table.name>.<attr.name>\</i> information using a {@link ResultSet}.
<class_common_javadoc(template="org/acmsl/queryj/templates/DAO.stg", C=C)>
 */
public static class <attr.name.capitalized>ResultSetExtractor
    extends  V24ResultSetSingleExtractor\<Map\<String, ?\>>
{
    /**
     * Constructs a new {@code <attr.name.capitalized>ResultSetSingleExtractor}.
     * @param sql the original SQL.
     * @param daoListener the dao listener.
     */
    public <attr.name.capitalized>SingleColumnResultSetSingleExtractor(
        <notnull(C=C)>final String sql,
        <nullable(C=C)>final DAOListener daoListener)
    {
        super(sql, daoListener);
    }

    /**
     * Extracts \<i><table.name>.<attr.name>\</i> information from given result set.
     * @param resultSet the result set.
     * @param sql the SQL used.
     * @param daoListener the {@link DAOListener} instance.
     * @return the data extracted.
     */
    @Override
    <notnull(C=C)>
    protected Map\<String, ?> extractData(
        <notnull(C=C)>final ResultSet resultSet,
        <notnull(C=C)>final String sql,
        <notnull(C=C)>final DAOListener daoListener)
    throws  SQLException,
            DataAccessException
    {
        return extractData(resultSet, getSql(), daoListener);
    }

    /**
     * Extracts \<i><table.name>.<attr.name>\</i> information from given result set.
     * @param resultSet the result set.
     * @return the information retrieved from the database.
     */
    @SuppressWarnings("unchecked")
    <notnull(C=C)>
    protected Map\<String, ?> extractValue(<notnull(C=C)>final ResultSet resultSet)
    throws  SQLException,
            DataAccessException
    {
        <notnull(C=C)>final Map\<String, ?> result = new HashMap\<String, Object>();

        int index = 0;

        <resultset_extractor_parameter_retrieval(
              name=attr.name.uncapitalized,
              getterMethod=attr.getterMethod,
              objectType=attr.objectType,
              isPrimitive=attr.primitive)>

        return result;
    }
}
>>
